/* 자바 프로그램 실행하기
1) 컴파일
- 개발자가 작성한 .java 파일을 
  플레이어가 실행할 수 있는 포맷으로 변환한다.
  변환하면 .class 파일이 생성된다.
- 컴파일을 실행하려면 컴파일을 해주는 프로그램을 사용해야 한다.
  그 프로그램을 컴파일러라 부른다.
  c:\Program Files\Java\jdk1.8.0_144\bin\javac.exe
- 컴파일 방법
  명령창에서 다음과 같이 실행한다.
  > "c:\Program Files\Java\jdk1.8.0_144\bin\javac.exe" Test01.java
  파워셀에서는 다음과 같이 실행한다.
  > & "c:\Program Files\Java\jdk1.8.0_144\bin\javac.exe" Test01.java

2) 실행
- 컴파일 된 .class 파일을 실행하려면 프로그램이 있어야 한다.
  그 프로그래밍을 인터프리터 또는 JVM이라 부른다.
- 실행 방법
명령창에서 다음과 같이 실행한다.
  > "c:\Program Files\Java\jdk1.8.0_144\bin\java.exe" Test01
  파워셀에서는 다음과 같이 실행한다.
  > & "c:\Program Files\Java\jdk1.8.0_144\bin\java.exe" Test01

3) javac.exe와 java.exe을 실행하기 위해 긴 디렉토리 경로까지 적어야 한다.
   이를 피하는 방법은?
- 운영체제의 PATH라는 환경변수에 javac.exe, java.exe가 들어 있는
  디렉토리 경로를 미리 등록하라!
 */
class Test01 {
  public static void main(String[] args) {
    System.out.println("Hello, world!");
  }
}



/* 소스 파일의 인코딩을 지정하기
 */
class Test02 {
  public static void main(String[] args) {
    System.out.println("안녕하세요!");
  }
}

/*
컴파일 할 때 인코딩 오류가 발생하는 이유?
- 윈도우에서 컴파일을 하면 인코딩 오류가 발생한다.
- 이유?
  자바 컴파일러는 소스 파일을 컴파일할 때
  운영체체가 기본으로 사용하는 문자형식으로 되어 있다고 간주한다.
  하지만, VisualStudio Code에서 자바 소스 파일을 저장할 때
  운영체제의 기본 문자 형식이 아닌 UTF-8이라는 형식으로 저장한다.
  그러니 컴파일러가 제대로 번역할 수 없는 것이다.
- 해결책?
  컴파일러에게 소스 파일의 문자 형식이 무엇으로 되어 있는지 알려줘라!
  > javac -encoding UTF-8 Test02.java

- 맥이나 리눅스에서는 오류가 발생하지 않는다.
  이유? 
  맥의 기본 문자 형식이 UTF-8이기 때문이다.

*/




/* .class 파일 분리하기
- .class 파일을 관리하기 쉽도록 별도의 폴더로 분리하는 방법을 알아보자!
- 왜 .class 파일을 소스 파일로부터 분리하는가?
 */
class Test03 {
  public static void main(String[] args) {
    System.out.println("안녕하세요!");
  }
}

/* 분리 
   > javac -d [.class 파일을 저장할 폴더] [소스파일명]
   예)
   > md bin
   > javac -d bin Test03.java

   이유?
   - 소스 파일과 클래스 파일을 분리함으로써
     소스 파일을 관리하기 쉽고,
     배포를 위해 클래스 파일을 추출하기도 쉽다.

  다른 폴더에 있는 클래스 실행하기
  > java -classpath [.class 파일이 있는 폴더] 클래스명
  > java -cp [.class 파일이 있는 폴더] 클래스명
  예)
  > java -classpath bin Test03
  > java -cp bin Test03

  운영체제에 .class 파일이 있는 폴더를 등록해두면 
  .class 파일을 실행할 때 마다 매번 -cp 또는 -classpath를
  사용하여 .class 파일이 있는 경로를 지정할 필요가 없다.
  > set CLASSPATH=[클래스파일이 있는 폴더1;폴더2;폴더3]
  예)
  > set CLASSPATH=c:\workspace\java-basic\bin
  > java Test03
*/



/* 소스 파일 분리하기
- 소스 파일을 관리하기 쉽도록 별도의 폴더로 분리하는 방법을 알아보자!
- 왜 소스 파일을 별도의 폴더로 분리하는가?
 */
class Test04 {
  public static void main(String[] args) {
    System.out.println("안녕하세요!");
  }
}

/* 분리 
   > javac -d [.class 파일을 저장할 폴더] [폴더명/.../소스파일명]
   예)
   $프로젝트> md src
   $프로젝트> javac -d bin src/Test04.java

   이유?
   - 소스 파일을 보다 쉽게 관리하기 위함.
*/




/* 소스 파일 분리하기 II
- Maven 프로젝트의 디렉토리 구조를 알아보자!
- 왜 Maven 프로젝트의 디렉토리 구조를 사용하는가?
 */
class Test05 {
  public static void main(String[] args) {
    System.out.println("안녕하세요!");
  }
}

/* Maven 프로젝트 디렉토리 구조
   $프로젝트폴더
      /src
        /main
          /java       <= 자바 소스 파일을 두는 폴더
          /resources  <= 프로그램 설정 파일을 두는 폴더
          /webapp     <= 웹 애플리케이션 관련 파일을 두는 폴더 
        /test
          /java       <= 자바 테스트 소스 파일을 두는 폴더
          /resources  <= 자바 테스트 관련 설정 파일을 두는 폴더
  이유?
  - 국제적으로 자바 프로젝트를 관리할 때 이 구조를 많이 사용한다.
  - 국제 표준.

  Gradle 빌드 도구를 이용하여 Maven 프로젝트 구조로 
  디렉토리를 자동 생성하기
  > gradle init --type java-application
  => Gradle 빌드 도구 관련 설정 파일들이 자동으로 생성된다.
  => 또한 Maven 프로젝트 구조에 맞춰서 폴더들이 자동생성된다.
  => 간단한 예제 파일이 자동 생성된 폴더에 저장된다.
  
  build.gradle
  => 자동으로 생성된 파일 중에서 개발자가 직접 손대는 파일
  => 이 파일에 빌드에 관련된 작업 내용을 기술한다.
  => 작업 명령은 groovy라는 언어를 사용해서 기술한다.
  => groovy는 자바 호환 언어이다. 즉 자바와 함께 사용할 수 있다.
  => 빌드 작업을 작성하는 자세한 사항은 문서를 보라!

  * 자바 호환 언어란?
  => 컴파일하면 .class 파일을 만드는 언어.
  => 바이너리 수준(bytecode 수준)에서 호환된다.
  => 자바로 만든 모든 코드를 100% 사용할 수 있고,
     자바에서도 호환 언어로 작성된 코드를 100% 사용할 수 있다.
  => 예) Scala, Groovy, Kotlin 등이 있다.
    
  Gradle을 이용하여 프로젝트를 빌드한다.
  > gradle build
  => 1) 의존하고 있는 외부 라이브러리를 자동으로 다운로드 받는다.
  => 2) build라는 폴더를 생성한다.
  => 3) build 폴더에 컴파일 된 파일들을 놓는다.
  => 4) 테스트 프로그램이 있으면 실행한다.

  라이브러리?
  - 개발자가 만든 코드들의 묶음
  - 보통 .jar 파일에 묶여서 배포된다.
  - JAR(Java ARchive)의 약자이다.
  - "archive"는 묶음을 의미한다.
  - 그런데 영어 사전에 "jar"라는 단어가 있다.
    의미는 "(꿀)단지"라는 뜻이 있어 묶음이라는 의미를 표현해 준다.
  - 압축을 할 때는 zip 알고리즘(압축공식)으로 압축한다.
    왜? zip 알고리즘은 특허로 등록되어 있지 않다.
  

*/





/* 다른 소스 파일의 코드를 참조할 때 컴파일 하는 방법
- 다른 소스 파일의 코드를 참조할 때, 컴파일 하는 방법을 알아보자!
- 다른 소스 파일의 코드를 참조하는 이유는?
 */
class Test06 {
  public static void main(String[] args) {
    Test06_other.printHello();   
  }
}

/*  [일반적인 컴파일 방법]
    $프로젝트폴더> javac -d bin -encoding utf8 src/main/java/Test06.java 
    => Test06 블록에서는 Test06_other라는 블록의 코드를 사용한다.
    => 그러나 컴파일러가 Test06_other라는 블록을 못찾기 때문에 오류가 발생한다.
    
    [다른 소스 파일을 참조하는 경우 컴파일 하는 방법]
    -sourcepath [참조하는 소스 파일이 들어 있는 폴더]
    $프로젝트폴더> javac ... -sourcepath src/main/java src/main/java/Test06.java 
    
 */





/* .java vs class {} vs .class
- .java 파일과 class {}과 .class 파일의 관계를 알아보자!
- .java 파일에 class 블록을 한 개만 두는 이유는?
 */
class Test07_A {}
class Test07_B {}
class Test07_C {}

/*  [.java 소스 파일의 컴파일 결과]
    - 각각의 class 블록 별로 .class 파일이 생성된다.
    - .java 파일 당 한 개의 .class 파일이 생성되는 것이 아니다!
    - .class 파일의 이름은 class {} 블록 이름과 같다.
 */






/* 공개하는 클래스 블록
- 클래스 블록을 공개하는 방법과 컴파일 하는 방법을 알아보자!
- 클래스 블록을 공개하는 이유?
 */

// 클래스 블록을 공개할 때는 앞에 public을 붙인다.
//public class Test07_D {}
public class Test07_2 {}
class Test07_E {}
class Test07_F {}
class Test07_G {}


/*  [.java 소스 파일의 컴파일 결과]
    - 컴파일 오류 발생!
    - 공개 클래스 블록의 파일명은 반드시 클래스 이름과 같아야 한다.

    [결론]
    - 한 소스 파일에는 한 개의 공개 클래스만 만들 수 있다.
    - 한 소스 파일에 비공개 클래스는 여러 개 만들 수 있다.
    - 그러나 유지보수를 쉽게 하기 위해서는 
      한 소스 파일 당 한 개의 클래스를 만드는 것이 좋다.
    - 왜? 파일 이름으로 어떤 클래스인지 바로 구분할 수 있기 때문이다.
 */






/* 코드와 주석
- 프로그램 명령을 작성할 때 주석을 다는 방법을 알아보자.
- 주석의 종류와 그 쓰임새를 알아보자!
*/

/**
이 클래스는 주석에 대한 설명을 위해 
만든 예제이다.
 */
public class Test08 {

  /**
   이 변수는 출력하려는 문자열을 저장하고 있다.
   */
  static String message = "Hello!";

  /** 프로그램을 시작할 때 제일 먼저 시작되는 명령어 블록이다.
      <b>"프로그램 엔트리(entry)"</b>라 부른다.
  */
  public static void main(String[] ags) {
    /* 표준 출력 장치(모니터)로 문자열을 출력하려면,
       다음 명령을 작성해야 한다.*/
    System.out.println(message); // 명령어 끝에 반드시 세미콜론(;)을 붙여라!
  }
}

// 주석은 컴파일할 때 제거된다.
// 코드에 대한 개발자의 의견이나 설명을 붙일 때 사용한다.

/* [여러 줄 주석]
여러 줄 주석을 
작성하고 싶을 때
사용한다.
*/

/* 여러 줄 주석을 작성할 때 이와 같이 모양을 꾸미기도 한다.
 * 이렇게 중간에 들어가는 wildcard(*) 문자는 아무 의미 없다.
 * 즉 중간에 wildcard를 넣지 않아도 된다.
 */

// [한 줄 주석]
// 줄이 끝날 때까지 주석으로 간주한다.

/**
   [javadoc(java document) 주석]
   - 프로그램 개발을 완료한 후 각 클래스나 메서드의 설명을 
     HTML 문서로 만들 때 사용한다.
   - 클래스 선언, 메서드 정의, 변수 선언 앞에 붙인다.
 */





/* 클래스와 패키지
- 패키지를 사용하여 클래스를 분류하는 방법을 알아보자! 
*/

public class Test09_1 {
  public static void main(String[] ags) {
    System.out.println("Hello!"); 
  }
}

/*  [패키지 무소속 클래스]
 *  - 위와 같이 특정 패키지에 종속되지 않은 클래스를 말한다.
 */





/* 클래스와 패키지
- 패키지를 사용하여 클래스를 분류하는 방법을 알아보자! 
- 패키지를 사용하는 이유?
*/

// 소스 파일에서 제일 처음에 패키지를 선언한다.
// 그러면 이후에 선언되는 모든 클래스들은 이 패키지에 소속된다.
package a;

public class Test09_2 {
  public static void main(String[] ags) {
    System.out.println("Hello!"); 
  }
}

/*  [패키지 클래스]
 *  - 위와 같이 특정 패키지에 소속된 클래스를 말한다.
 *  - 컴파일러가 패키지 클래스를 컴파일 할 때 
 *    패키지에 해당하는 폴더를 자동 생성한다.
 * 
 *  [패키지 클래스를 실행하는 방법]
 *  1) 패키지 무소속 클래스
 *     > java -cp ./build/classes/java/main Test09_1
 *  2) 패키지 소속 클래스
 *     패키지명을 포함하여 클래스명을 지정한다.
 *     > java -cp ./build/classes/java/main a.Test09_2
 *  3) CLASSPATH 등록 후 실행하기
 *     (Windows)
 *     > set CLASSPATH=build\classes\java\main
 *     > java a.Test09_2
 *     
 *     (linux & unix)
 *     > export CLASSPATH=./build/classes/java/main
 *     > java a.Test09_2
 * 
 *  [주의]
 *  - 패키지를 클래스를 실행할 때 패키지 이름까지 포함해야 한다.
 *  - "-cp" 또는 "-classpath"에 패키지명까지 포함해봐야 소용없다.
 *  예)
 *    > java -cp ./build/classes/java/main/a Test09_2   <== 실행 오류!
 */





/* 클래스와 패키지
- 패키지를 사용하여 클래스를 분류하는 방법을 알아보자! 
- 패키지를 사용하는 이유?
*/

// 소스 파일에서 제일 처음에 패키지를 선언한다.
// 그러면 이후에 선언되는 모든 클래스들은 이 패키지에 소속된다.
package a.b.c; // 하위 패키지는 점(.)으로 구분한다.

public class Test09_3 {
  public static void main(String[] ags) {
    System.out.println("Hello!"); 
  }
}

/*  [패키지 클래스를 실행하는 방법]
 *  > java -cp ./build/classes/java/main a.b.c.Test09_3
 *  
 */





/* 클래스와 패키지
- 패키지를 사용하여 클래스를 분류하는 방법을 알아보자! 
- 패키지를 사용하는 이유?
*/

// 소스 파일에서 제일 처음에 패키지를 선언한다.
// 그러면 이후에 선언되는 모든 클래스들은 이 패키지에 소속된다.
package a.b.c; // 하위 패키지는 점(.)으로 구분한다.

public class Test09_4 {
  public static void main(String[] ags) {
    System.out.println("Hello!"); 
  }
}

/*  [패키지 클래스의 소스 관리]
 *  - 소스 파일을 쉽게 관리하기 위해 
 *    보통 패키지 이름에 해당하는 폴더를 만들고
 *    그 폴더에 소스 파일을 둔다.
 *  
 */






/* 패키지 이름짓는 규칙
- 패키지 이름이 겹치지 않도록 짓는 방법을 알아보자!
- 패키지 이름으로 왜 도메인명을 사용하는가?
  왜 도메인명을 꺼꾸로 사용하는가?
*/

// 1) 보통 패키지명이 겹치지 않도록 하기 위해 도메인명을 사용한다. 
// 2) 폴더 관리를 쉽게 하기 위해 
//    상위 도메인명이 상위 폴더가 될 수 있도록 
//    도메인명을 꺼꾸로 사용한다.
//    예) com.xxx.제품명.하위패키지
package kr.co.bitcamp.java100;

public class Test09_5 {
  public static void main(String[] ags) {
    System.out.println("Hello!"); 
  }
}





// # 자바 소스 파일 기본 구조
//

// 1) 클래스가 소속된 패키지를 선언한다.
// package 패키지명;
package bitcamp.java100;

// 2) 클래스를 선언한다.
// public class 클래스명 {}
public class Test10_1 {

    // 3) 클래스를 실행할 때 가장 먼저 실행되는 블록을 선언한다.
    // 이 블록이 없으면 클래스를 실행할 수 없다.
    public static void main(String[] args) {
        System.out.println("Hello!");
    }
}




// # 콘솔창으로 출력하기 

package bitcamp.java100;

public class Test10_2 {

    public static void main(String[] args) {

// 자바에서 프로그래밍 할 때 도구를 사용하는 방법
// 1) 도구함.기능명
// 2) 도구함.객체명.기능명
// 3) 객체명.기능명
        
// System => 도구함. 클래스라고 부른다.
// out => 객체(object) = 실체(instance)
// println => 기능
// "Hello" => 매개변수(parameter). 기능을 수행하기 위해 전달하는 조건.
        System.out.println("Hello!");

// 도구함에 있는 기능을 바로 사용하는 경우
// - 어떤 기능은 인스턴스가 있어야만 사용 가능하다.
// - 어떤 기능은 클래스만 있으면 사용 가능하다.
        long currMillis = System.currentTimeMillis();
        System.out.println(currMillis);
    }
}






// # print()와 println() 

package bitcamp.java100;

public class Test10_3 {

    public static void main(String[] args) {
// print()
// => 출력한 이후에 줄바꿈 기호가 붙지 않는다.
        System.out.print("홍길동");
        System.out.print("임꺽정");
        System.out.println(); // 줄바꿈 코드 출력

// println()
// => 출력한 이후에 줄바꿈 기호가 붙는다.
        System.out.println("홍길동");
        System.out.println("임꺽정");
    }
}






// ## printf() 사용법
// - printf()의 사용법을 알아보자.

package bitcamp.java100;

public class Test10_4 {

    public static void main(String[] args) {
// printf(): 특정 형식의 문자열을 만들어 출력한다.
// => 형식
//    %[argument_index$][flags][width][.precision]conversion
//

// => conversion 사용법
//    %s, %S : 문자열
//    %c, %C : 문자 
//    %d : 10진수(decimal) 숫자
//    %o : 8진수(octal) 숫자
//    %x, %X : 16진수(hexadecimal) 숫자
//    %h, %H : Integer.toHexString(arg.hashCode())의 리턴 값.
//    %f : 부동소수점(floating point) 숫자
//    %b, %B : boolean 값 
//    %t, %T : Date/Time 값
//    %n : 줄바꿈. \n 과 같다. 
        System.out.printf("%s,%c,%d,%o,%x,%h,%f,%b,%tY\n", 
            "홍길동",'가',100, 100, 100, 100, 
            3.14, true, new java.util.Date());

// => [.precision]
        System.out.printf("%f, %.1f, %.2f, %.3f, %.4f, %.5f\n", 
            3.141592, 3.141592, 3.141592, 3.141592, 3.141592, 3.141592);

// => [argument_index$]
        System.out.printf("%1$f, %1$.1f, %1$.2f, %1$.3f, %1$.4f, %1$.5f\n", 3.141592);

// => [width]
        System.out.printf("%1$4s,%1$10s,%2$5.2f,%2$10.3f\n", "홍길동", 3.14);

// => [flags]
//    - : 왼쪽 정렬
        System.out.printf("'%10s','%-10s'\n", "홍길동", "임꺽정");
//    + : 부호 출력 
        System.out.printf("%d, %+d\n", 100, 100);
//    0 : 빈자리를 0으로 채우기
        System.out.printf("%5d, %05d\n", 123, 123);

// => 날짜/시간 다루기 : %t[날짜관련 접미사]
//    H : Hour. 00 ~ 23
//    I : Hour. 01 ~ 12
//    M : Minute. 00 ~ 59
//    S : Second. 00 ~ 60
//    p : 오전(am), 오후(pm) 출력
        System.out.printf("%1$tH, %1$tI, %1$tM, %1$tS, %1$tp\n", 
            new java.util.Date());
        System.out.printf("%1$tH:%1$tM:%1$tS\n", new java.util.Date());

//    Y : Year. 4자리
//    y : Year. 2자리
//    m : Month. 01 ~ 12
//    d : Day. 01 ~ 31
//    e : Day. 1 ~ 31
//    A : Week. "Sunday"
//    a : Week. "Sun"
//    B : Month name. "January"
//    b : Month name. "Jan"
        System.out.printf("%1$tY, %1$ty, %1$tm, %1$td, %1$te\n", 
            new java.util.Date());
        System.out.printf("%1$tm, %1$tB, %1$tb\n", 
            new java.util.Date());
        System.out.printf("%1$tA, %1$ta\n", 
            new java.util.Date());    
    }
}










