
@ 크롬에서 오른쪽 마우스 해제

  F12 => F1 => Preferences 의 Debugger 에서 Disable JavaScript 체크
  
  주소 오른쪽에서 <> 아이콘 클릭한 후 자바스크립트 계속 차단 체크후 확인 클릭

  F5(새로고침)

@ cmd 종료 : ctrl + c



기트허브 :  https://git-scm.com

Atom : https://atom.io/

REPL
read
evaluate
print
loop


jshell


Vim  ,   pix2code

* gradle  =>  gradle-4.2-bin   binary only
https://gradle.org/releases/   압축푼후  환경변수에 추가



* git 사용법

자격 삭제 : 사용자 계정 및 가족보호 => Windows 자격 증명 관리에서 git 제거


git> git config --global user.name "zerox7066"
git> git config --global user.email "zerox7066@gmail.com"


git init



@ github 복사

  - git clone /로컬/저장소/경로

  - git clone 사용자명@호스트:/원격/저장소/경로


  ex)  Clone or download 버튼 클릭

    git> git clone https://github.com/zerox7066/bitcamp.git


@ github 업로드

1. 로컬 저장소에 백업할 명단 작성 
   
   bitcamp> git add .      => 모든 파일 및 폴드

   bitcamp> git add <파일이름>


2. 로컬 저장소에 백업

   bitcamp> git commit -m '백업이유'
   bitcamp> git commit -m '.'

3. 서버의 원격 저장소에 업로드  =>  로그인 화면이 나타남
   >git push


@ github 다운로드
  
  java100> git pull




https://spring.io/



https://www.egovframe.go.kr


https://cs50.harvard.edu/


https://www.edx.org/professional-certificate/uc3mx-introduction-java-programming


http://mooc.org/



* github desktop용

https://desktop.github.com/


https://gradle.org/



빌게이츠 생각의 속도

스티브 잡스(보급판)

조너선 아이브

Refactoring



* 클래스 파일이 있는 경로로 classpath 설정

>set CLASSPATH=C:\workspace\java-basic\build\classes\java\main


* jar : 배포파일



* gradle 설치
  - 환경변수의 시스템 변수 - path에 gradle 압축푼 경로로 삽입
C:\gradle-4.2\bin  삽입


* gradle 생성
C:\workspace\java-basic\test>gradle init --type java-application

* gradle build
C:\workspace\java-basic\test>gradle build


* gradle run
C:\workspace\java-basic\test>gradle run


* gradle 컴파일
C:\workspace\java-basic\test>gradle compilejava


* gradle tasks



git scm

gradle


d2coding


구글 한중일 폰트

google noto fonts       South Korea


"editor.fontFamily": "D2Coding, Consolas"


80칸 준수




* gradlew run



* java-basic> java -cp .\build\classes\java\main bitcamp.java100.Test10




* Classpath 설정

java-basic> set CLASSPATH=.\build\classes\java\main

java-basic> java bitcamp.java100.Test10




https://docs.oracle.com/javase/8/docs/api/

http://docs.oracle.com/javase/9/docs/api/index.html?overview-summary.html



// java script Node.js 설치

https://nodejs.org/en/





// 자바 스크립트로 만든 모듈 설치 ( Node Package Modules ) : 크롬의 오픈소스 엔진
  - npm이란 Node Package Modules의 약자다. Node.js에서 사용가능한 모듈들을 패키지화시켜 모아놓은 것이다.

https://electron.atom.io/

아무폴더> npm install -g electron


java-basic> node     exit : ctrl + d


java-basic> jshell     exit : ctrl + d


@ 코드 알고리즘
https://codefights.com/




@  npm 사용   npm이란 Node Package Modules의 약자다.

https://github.com/eomcs/eomcs-codebook

git 다운로드

git> git clone https://github.com/eomcs/eomcs-codebook.git

* electron

git\eomcs-codebook> npm install


git\eomcs-codebook> npm start



call by value : 호출할 때 값을 넘김
call by reference : 호출할 때 주소를 넘김


Stack Memory : 로컬 변수는 스택 메모리에 생성
Heap Memory :  new 연산자를 통해 만든 배열과 사용자 정윽 객체는 Heap 영역에 생성














@ 배열 / 사용자 정의 for 문
public class Score {
    String name;
    int[] subjects = new int[3];
    int sum;
    float aver;
}

static void compute(Score score) {
    // 배열 for 문
    for (int sub : score.subjects) {
        score.sum += sub;
    }		
    score.aver = score.sum / 3f;
}

public static void main(String[] args) {
    Score[] scores = {new Score(), new Score(), new Score()};
    
    init(scores[0], "홍길동", 100, 90, 80);
    init(scores[1], "임꺽정", 80, 80, 80);
    init(scores[2], "유관순", 100, 100, 100);
    
    // 사용자 정의 객체 for 문
    for (Score s : scores) {
        Score.print(s);
    }
}


@ 메서드 리턴값이 타입이 다른 여러개의 값을 반환
java.util.ArrayList<String> list = new java.util.ArrayList<String>();
list.add("홍길동");
list.add("임꺽정");

java.util.ArrayList<Integer> list = new java.util.ArrayList<Integer>();
list.add(1);
list.add(2);

public class Test17_7 {
    // 타입이 다른 여러개의 값을 반환
    static java.util.ArrayList m1() {
        java.util.ArrayList list = new java.util.ArrayList();
        list.add("홍길동");
        list.add(20);
        list.add(false);
        list.add(4.12f);
        list.add('M');

        // 객체(상자)를 리턴하는 것이 아니라, 객체의 주소를 리턴한다.
        return list;
    }
    
    public static void main(String[] args) {
        java.util.ArrayList a = m1();
        
        // ArrayList 에서 for 문
        for (Object v : a) {
            System.out.println(v);
        }
        System.out.println("--------------------------------------------------");
    }
}


@ 배열 Length을 이용하는 방법
for (int i = 0; i < scores.length; i++) {
    for (int j = 0; j < scores[i].arr1.length; j++) {
        for (int k = 0; k < scores[i].arr1[j].length; k++) {
            System.out.printf("%4s, %4d, %4d, %4d, %4d, %5.1f, %-4d\n",
            scores[i].name, scores[i].kor, scores[i].eng, scores[i].math, 
            scores[i].sum, scores[i].aver, scores[i].arr1[j][k]);
        }
    }
}


java.util.HashSet<String> set = new java.util.HashSet<String>();
set.add("홍길동");
set.add("임꺽정");
for (String n : set) {
    System.out.println(n);
}

String[] names = {"홍길동", "임꺽정", "유관순", "안중근", "윤봉길"};
for (String n : names) 
    System.out.println(n);

int[] kor = {100, 90, 80, 90, 50, 80};
for (int score : kor) {
    System.out.println(score);
}


//: 메모리 준비 값 저장
static Score createScore(String name, int kor, int eng, int math) {        
    //: 메모리 준비
    Score s = new Score();
    
    //: 메모리에 데이타 넣기
    s.name = name;
    s.kor = kor;
    s.eng = eng;
    s.math = math;
    s.sum = s.kor + s.eng + s.math;
    s.aver = s.sum /3f;
    
    //: 메모리 주소 리턴
    return s;
}

static void m1(int... values) {
    System.out.printf("아규먼트 갯수 : %d\n", values.length);
    for (int v : values) {
        System.out.println(v);
    }
    System.out.println("--------------------------------------------------");
}



mutable
immutable

@ String Class
  8이하는 private final char value[];
  9에서는 private final byte[] value;



// static method(class method) : 인스턴스의 값을 사용하려면 반드시 파라미터로 받아야 한다.
// non static method(instance method) : 메서드의 내장변수 this를 사용



@ class 문법

1) 새로운 데이타 타입을 정의할 때(새로운 메모리 설계)
   새 메모리의 값을 다룰 수 있는 연산자가 필요할 때
   인스턴스 메서드


2) 연관된 메서드를 분류 


@ 정규 표현식

java.util.regex.Pattern 클래스이 API 문서를 참조

https://www.slideshare.net/


웹 크롤러


@ Matcher 의  find()와 matches() 의 차이점

http://diyall.tistory.com/769

* find()
   - 대상 문자열에서 해당 패턴을 검색하여 일치하는 패턴이 일부라도 존재하면 true를 리턴한다.
   - matches()에 비해서 상대적으로 활용도가 높을 것 같다.
 
* matches()
   - 대상 문자열 전체가 해당 패턴과 일치하면 true를 리턴한다.
   - 문자열의 처음부터 끝까지 정규식을 만족시켜야 한다.(^과$가 붙었다고 생각하자)
 
Matcher 클래스 메서드들
find() : 패턴이 일치하는 경우 true를 반환하고, 그 위치로 이동(여러개가 매칭되는 경우 반복 실행가능)
find(int start) : start위치 이후부터 매칭검색을 수행
start() : 매칭되는 문자열 시작위치 반환
start(int group) : 지정된 그룹이 매칭되는 시작위치 반환
end() : 매칭되는  문자열 끝 다음 문자위치 반환
end(int group) : 지정되 그룹이 매칭되는 끝 다음 문자위치 반환
group() : 매칭된 부분을 반환
group(int group) : 매칭된 부분중 group번 그룹핑 매칭부분 반환
groupCount() : 패턴내 그룹핑한(괄호지정) 전체 갯수 반환
matches() : 패턴이 전체 문자열과 일치할 경우 true 반환



[정규표현식] 정규표현식 활용하기
Mar 22, 2015

대량의 텍스트로 이루어진 데이터를 다루어야 할 경우가 있다.
이럴 때 정규표현식을 이용하면 시간을 절약하고 오류를 줄일 수 있다.
스크립트, 정규표현식을 공부해 놓으면 대량의 텍스트 데이터를 처리할 때 큰 도움이 된다.

반복 찾기
위치 찾기
하위 표현식 사용하기
역참조 사용하기
전방탐색과 후방탐색
문법
반복 찾기
수량자의 문법을 참고하자

*?, +?, {n,}?과 같이 lazy한 수량자를 이용하여 원하는 결과를 찾는게 중요하다.
*, +, {n}과 같은 수량자는 기본적으로 greedy하다.
greedy한 수량자는 텍스트를 뒤에서부터 조회하여 가능한 큰 덩어리를 찾아준다.

<[Bb]>.*</[Bb]> - <B>AK</B> and <B>HI</B>
<[Bb]>.*?</[Bb]> - <B>AK</B>, <B>HI</B>
위치 찾기
위치 지정, 변경자의 문법을 참고하자

(?m)을 지원하지 않는 정규 표현식 구현이 많다.
(?m)을 이용하면 각 라인별로 구분하여 ^, $가 동작하지만 \A, \Z는 정상적으로 동작하지 않는다.

하위 표현식 사용하기
하위 표현식은 ()를 이용한다.
IPv4주소를 조회하기 위한 정규표현식을 참고하라

(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.)(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.)((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.)(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))

앞에 3개 중복되는 표현식을 하위표현식으로 묶어서 다음과 같이 변경할 수 있다.

(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))\.){3}(((\d{1,2})|(1\d{2})|(2[0-4]\d)|(25[0-5]))

역참조 사용하기
역참조와 전후방탐색, 대소문자 변환의 문법을 참고하자
역참조는 참조하는 표현식이 하위 표현식일 때 동작한다.

<h>태그로 묶여있는 부분을 찾기 위한 정규표현식을 참고하라

<[hH]([1-6])>/*?</[hH]\1>

\1은 ([1-6])부분을 역참조하여 해당 태그를 닫아준다.

정규표현식 구현에 따라 역참조 방법이 다르다. 해당하는 문법을 확인하여 사용하자.
<h1> 태그로 감싸인 텍스트를 대문자로 변환하여보자

정규표현식: (<[Hh]1>)(.*?)(</[Hh]1>)
치환: $1\U$2\E$3
$1: (<[Hh]1>), $2: (.*?), $3: (</[Hh]1>)을 의미한다.

전방탐색과 후방탐색
역참조와 전후방탐색의 문법을 참고하자

전후방 탐색을 이용하면 $150, $130, 23, 25과 같은 텍스트에서 특정 텍스트 주변의 텍스트를 조회할 수 있다.
정규표현식: (?<=\$)[0-9.]+

문법
기본 메타 문자
. 모든 문자와 일치
| 왼쪽 혹은 오른쪽과 일치
[] 문자 집합 구성원 중 하나와 일치
[^] 문자 집합 구성원을 제외하고 일치
- 범위 정의([A-Z]와 같은 형태)
\ 다음에 오는 문자를 이스케이프

수량자
* 문자가 없는 경우나 하나 이상 연속하는 문자 찾기
*? 게으른 * 문자
+ 문자 하나 이상 찾기
+? 게으른 + 문자
?문자가 없거나 하나인 문자 찾기
{n} 정화히 요소와 n번 일치
{m,n} 요소와 m번에서 n번 일치
{n,} 요소와 n번 이상 일치
{n,}? 게으른 {n,}

위치 지정
^ 문자열의 시작과 일치
\A 문자열의 시작과 일치
$ 문자열의 끝과 일치
\Z 문자열의 끝과 일치
\< 단어의 시작과 일치
\> 단어의 끝과 일치
\b 단어 경계와 일치
\B \b와 반대로 일치

특수한 문자
[\b] 역스페이스
\c 제어문자와 일치
\d 모든 숫자와 일치
\D \d와 반대
\f 페이지 넘기기(form feed)
\n 줄바꿈
\r 캐리지 리턴
\s 공백 문자와 일치
\S \s와 반대로 일치
\t 탭
\v 수집 탭
\w 영숫자 문자나 밑줄과 일치
\W \w와 반대로 일치
\x 16진수 숫자와 일치
\0 8진수 숫자와 일치

역참조와 전후방탐색
() 하위 표현식 정의
\1 첫 번째 일치한 하위 표현식. 두번째 일치한 하위 표현식은 \2로 표기하는 방식 
?= 전방탐색
?<= 후방탐색
?! 부정형 전방탐색
?<! 부정형 후방탐색
?<backreference>true 조건 지정
?<backreference>true|false else 표현식 조건 지정

대소문자 변환
\E \L 혹은 \U 변환을 끝냄
\l 다음에 오는 글자를 소문자로 변환
\L \E를 만날 때까지 모든 문자를 소문자로 변환
\u 다음에 오는 글자를 대문자로 변환
\U \E를 만날 때까지 모든 문자를 대문자로 변환

변경자
(?m) 다중행 모드


@ 정규식 MSDN

https://msdn.microsoft.com/ko-kr/library/28hw3sce(v=vs.100).aspx



@ Auto-Boxing / Auto-Unbixing



@ Refactoring
  소스코드를 정돈,  유지보수 쉽다,  속도는 떨어짐,  코드의 가독성이 좋다


@ Optimizing 
  속도 개선,   알고리즘에 중점,    코드의 복잡도가 상승

1단계 : 변수 사용해서 한개의 데이타로 작성

2단계 : 배열을 사용해서 여러개의 데이타로 작성

3단계 : 사용자 정의 타입을 사용한다.

3단계 : 메서드 작성

4단계 : 예외처리

5단계 : 정교하게 예외 처리

6단계 : 예외를 구분하기




@ 배열의 Index는 4Byte 최대 21억까지 가능


@ 숫자 카운터

static int[] countNumbers(long value) {
    int[] cnt = new int[10];
    
    while (value > 0) {
        cnt[(int)(value % 10)]++;
        value /= 10;
    }
    return cnt;
}


@ 문자인 숫자를 카운터 

static int[] countNumber(StringBuffer value) {
    int[] cnt = new int[10];

    for (int i = 0; i < value.length(); i++) {
        cnt[value.charAt(i) - '0']++;
    }
    return cnt;
}



@ gradle 버전 수정

 /java-basic/gradle/wrapper/gradle-wrapper.properties 파일에서 

원본 : distributionUrl=https\://services.gradle.org/distributions/gradle-4.2-bin.zip

수정 : distributionUrl=https\://services.gradle.org/distributions/gradle-4.2.1-bin.zip





abstract        추상 클래스 또는 메소드
break	        현재 루프를 멈추거나 레이블이 붙은 수행문을 멈춘다
byte	        부호 있는 8비트 정수타입
case	        switch 문에서의 레이블
char	        16비트 유니코드 문자타입
continue	루프 본문에서 남은 부분을 뛰어넘는다
default	        switch 문에서 기본 레이블
do	        본문이 적어도 한 번 실행되는 루프
extends	        이 클래스가 다른 클래스의 하위 클래스임을 나타냄
implements	클래스가 인터페이스를 구현한다는 걸 나타냄
import	        패키지 이름없이 클래스 이름만으로 사용하는 걸 허용
instanceof	객체 타입이 주어진 타입 또는 그 타입의 하위타입인지 판단
interface	오직 추상 메서드와 상수만 포함하는 추상타입
native	        자바가 아닌 코드로 구현된 메서드
new	        객체에 메모리 할당
null	        아무 객체도 참조하지 않는 참조값
private	        같은 클래스의 메서드로만 접근가능
protected	같은 클래스, 하위 클래스, 같은 패키지에 있는 클래스의 메서드에서만 접근가능
short	        16비트 정수타입
static	        개별적인 인스턴스가 아닌, 하나의 클래스에서 정의되는 요소
super	        상위 클래스의 생성자나 메서드 호출
synchronized    한 번에 하나의 스레드만 접근할 수 있는 코드 부분
throw	        예외를 던진다
throws	        메서드가 던질 수 있는 예외
transient	연속되지 않는 필드
volatile	동기화 과정 없이 여러 개 스레드에 의해 갱신될 수 있는 필드


기본 자료형 boolean, byte, char, short, int, long, float, double

접근 지정자 private, default, protected, public

클래스 관련 키워드 class, extends, abstract, interface, implements

객체 관련 키워드  new, this, super, null, instanceof

메소드 관련 키워드  void, return

제어문  if, else, switch, case, default, for, do, while, break, continue

논리 값  true, false

예외 처리  try, catch, finally, throw, throws

기타  package, import, static, final, volatile, transient, synchronized, native, strictfp

사용되지 않는 키워드 goto, const


get/set , add/remove , create/destroy , start/stop , insert/delete , increment/decrement , old/new , begin/end , first/last , up/down , min/max , next/previous , old/new , open/close , show/hide , suspend/resume 



get/set, add/remove, create/destroy, start/stop, insert/delete, increment/decrement,
old/new, begin/end, first/last, up/down, min/max, next/previous, old/new, open/close
show/hide, suspend/resume



































