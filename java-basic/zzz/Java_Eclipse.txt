환경변수 설정 => C:\Program Files\Java\jdk-9\bin;

   (Parentheses:Round Bracket)    [Square Bracket]    <Angle Bracket>    {Brace}

JAVA_HOME : C:\Program Files\Java\jdk-9

Path  : C:\Program Files\Java\jdk-9\bin;C:\gradle-4.2\bin;C:\cygwin64\usr\include;C:\cygwin64\bin;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\64bit\;c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;C:\Program Files\nodejs\;C:\Program Files\Git\cmd;C:\gradle-4.2\bin



@ 이클립스설치

  - Eclipse IDE for Java EE Developers 설치



@ 이클립스에서 jdk9 실행 설정

1) eclipse.ini  수정

C:\Users\bit-user\eclipse\jee-oxygen 에서 eclipse.ini  수정


-Dosgi.requiredJavaVersion=1.8
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication

-Dosgi.requiredJavaVersion=1.8



-Dosgi.requiredJavaVersion=9       =====>  수정
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication
--add-modules=ALL-SYSTEM           =====>  추가
-Dosgi.requiredJavaVersion=9       =====>  수정


2) jdk9 설치 확인

Help  =>  Elclipse Martketplace 에서 Java 9 검색해서 Java 9 Support for Oxygen 4.7 설치

Perferences  =>  Java  =>  Installed JREs  =>  Add 버튼 클릭 =>  Standard VM 선택  
             =>  Next 버튼 클릭 =>  JRE home에서 => Diretory 버튼 클릭해서 jdk-9 폴더 선택


- Java jdk9 설치 확인
- eclipse jdk9 검색



@ workspace 에러 발생할 경우 폴더 이름 변경후 소스 파일 복사
   An error has occured. See the log file
   C:\Users\User\elcipse-workspace\.metadata\.log


@ Run 할때 에러 메시지 처리 :  
 # Exception in thread "main" java.lang.Error: Unresolved compilation problem:
   - Bin 폴더 삭제
   - Projcet => Clean



@ Perferences 설정 

General  =>  Apperance  =>  Theme  =>  Dark

General  =>  Apperance  =>  Colors and Font  =>  Basic  =>  Edit Text
             : 기본 Console Font
             => D2Coding

General => Content Types => Java Class Fiel => Default encoding => UTF-8 => Update

General  =>  Editors  =>  Text Editors
    
             Insert space for tabs
             Show print margin
             Show line numbers
             Show whitespace charaters   Carriage Return, Line Feed 체크 해제
                                         Transparency level( . 투명도)

General => Editors => Text Editors => Spelling => Encoding => Default(UTF-8)

General =>  Workspace  =>  Text file encoing   Other UTF-8 설정

Java  =>  Code Style  =>  Formatter  =>  New 클릭 my 입력후 OK 클릭
                                         Tab policy에서  Spaces only 설정


Web  =>   CSs Files/Htm Files/JSP Files  =>  UTF-8 설정



폰트 d2coding 사용 
  https://github.com/naver/d2codingfont/releases
  "C:\Windows\Fonts\" 경로에 복사

  크롬 기본 글꼴 : 맞춤
  익스플로어 기본 글꼴 : 웹 페이지 글꼴(Gulim), 일반 텍스트 글꼴(GulimChe)



@ View 초기화
  Window => Perspective  => Open Perspective  => Other  => Java EE

@ Eclipse에서 Project Explorer / Navigator  /  Outline / Task List
  Window  =>  Show View  =>  Other  에서 맨위에서 검색






@ Projec Import Gragle 사용


1) gradle 명령어 모음

build.gradle             https://docs.gradle.org/4.2.1/userguide/eclipse_plugin.html

apply plugin: 'eclipse'


java-basic> gradle init --type java-application


java-basic> gradlew tasks --all


java-basic> gradlew EclipseProject


java-basic> gradlew cleanEclipseProject


java-basic> gradlew EclipseClasspath


java-basic> gradlew cleanEclipseProject


java-basic> gradlew Eclipse


java-basic> gradlew cleanEclipse




2) build.gradle 수정해서 jdk9으로 설정


apply plugin: 'eclipse'


eclipse {
  jdt {
    //if you want to alter the java versions (by default they are configured with gradle java plugin settings):
    sourceCompatibility = 9
    targetCompatibility = 9
    javaRuntimeName = "JavaSE-9"

    file {
      whenMerged { jdt
      }

      withProperties { properties ->
        properties["org.eclipse.jdt.core.compiler.codegen.targetPlatform"] = "9"
        properties["org.eclipse.jdt.core.compiler.source"] = "9"
        properties["org.eclipse.jdt.core.compiler.compliance"] = "9"
      }
    }
  }
}


3) gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

java-basic> gradlew cleanEclipse

java-basic> gradlew Eclipse


- C:\Users\bit-user\git\bitcamp\java-basic 폴더에서 .classpath 파일에서 JavaSE-9 설정 확인
  	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/
         org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-9/"/>

- C:\Users\bit-user\git\bitcamp\java-basic\.settings 폴더에서 org.eclipse.jdt.core.prefs 확인
  org.eclipse.jdt.core.compiler.codegen.targetPlatform=9
  org.eclipse.jdt.core.compiler.source=9
  org.eclipse.jdt.core.compiler.compliance=9


4) eclipse 에 Import

File => Import => General => Existing Projects into WorkSpace => Browse(폴더선택)
        - Select root directory : 압축 해제된 프로젝트 폴더
        - Select archive file   : 압축 상태인 프로젝트 압축파일



5) Import 에러

  오류: 기본 클래스 bitcamp.java100.Test16_1을(를) 찾거나 로드할 수 없습니다.
  원인: java.lang.ClassNotFoundException: bitcamp.java100.Test16_1

  Project Context Menu => Proerties => Java Build Path 에서 jar 경로확인
  git에서 다운 받았기 때문에 Users 가 bit-user로 되어 있음
  노트북은 Users 가 user로 되어 있음

  gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse

  한 후 다시 Import 한다.


6) Import 의 Project 명이 폴더명과 다른경우(다른 폴더 복사했을 경우)

  - settings.gradle 파일에서 rootProject.name 변경

    rootProject.name = 'bitcamp-java-basic' => rootProject.name = 'java-basic'

  - .project 파일에서 <projectDescription> 변경
 
    <name>bitcamp-java-basic</name>  =>  <name>java-basic</name>


7) Synchronize gradle projects with workspace failed due to an error configuring eclipse

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse
   
   





@@ Eclipse에서 Git 사용


@ Git Push 및 Pull

  Window  =>  Show View  =>  Other  =>  Git Repositories
  Window  =>  Show View  =>  Other  =>  Git Staging

  Git Repoitories 에서 해당 git에서 오른쪽 Context Menu  =>  Push to Stream

  Git Staging 에서 Unstaged Changes 에서 Staged Changes 로 파일 이동하고
  Commit Message에 메시지 입력

  Commit and Push 클릭해서 로그인

  한번 Commit 하면 이클립스 다시 실행





@ Eclipse에서 Git 자동로그인 해제

  Window  =>  Preference  =>  General  =>  Security  =>  Secure Storage  =>  Contents Tab에서 삭제





@ 단축키   [Ctrl + Shift + L]

===== 소스 네비게이션 =====

 -. 자동 완성 해제

    Windows > Preferences > Java > Editor > Typing > Automatically close 에서 필요 없는 기능 선택해제

 -. window > New Window  :  이클립스 새창

 -. Ctrl + 마우스커서(혹은 F3) : 클래스나 메소드 혹은 멤버를 상세하게 검색하고자 할때

 -. Ctrl + M : 현재 활성화된 뷰나 에디터 최대화
 -. Ctrl + F6 : 소스간 이동
 -. Ctrl + F7 : 뷰간 이동 ( 에디터 최대창에서 Project Explorer 창 보인)

 -. F3         : 선언된 변수로 이동, 메소드 정의부로 이동
 -. F4         : 클래스명을 선택하고 누르면 해당 클래스의 Hierarchy 를 볼 수 있다.
 -. Ctrl + O   : 해당 소스의 메소드 리스트를 확인하려 할때
 -. Ctrl + PageUp, Ctrl + PageDown : 소스탭 이동


 -. Alt + Left / Right Arrow  : 이전 소스 위치로 커서 이동
 -. Alt + Up / Down Arrow   : 선택한 소스 위치 변경



===== 소스 코드 편집 =====

 -. Ctrl + Space       :  컨텐트 어시스트
 -. Ctrl + Shift + M : 특정 클래스 Import
 -. Ctrl + Shift + O : 자동으로 Import

 -. Ctrl + /           :  주석 토글
 -. Ctrl + Shift + /   :  블록 주석 추가
 -. Ctrl + Shift + \   :  블록 주석 삭제

 -. Ctrl + 방향키  : 문자열 이동
 -. Ctrl + Shift + 방향키 : 문자열 선택
 -. Shift + Alt + Left / Right Arrow : 블록 선택 (Up/ Down은 다른 기능)

 -. Shift + Alt + a : 블록 복사 => 마우스가 십자가로 바뀜


 -. Ctrl + H 단축키를 Open Search Dialog을 File Search로 변경 : 단축키 변경관 같음
    
    Open Search Dialog 기본 정보 : Binding(Ctrl + H), When(In Windows)
    
    
 -. Window > Preference > Keys > Command에서 File Search 이동 > 
    
    Binding 에 원하는 단축키 클릭 / In Windows > Apply


 -. Ctrl + Shift + V : File Search (단축키 개인 등록)
    

 -. CTRL+ F : 현재 파일에서 특정 문자를 찾거나 찾은 문자를 교체하는 방법

 -. CTRL+ SHIFT + R : 프로젝트에 포함된 리소스(여기서는 파일)중에 찾는 방법

 -. CTRL+ H : 자세하고 가장 다양한 방법으로 찾을 수 있는 방법 정규표현식 및 다채롭게 찾을수 있습니다.

 -. CTRL + SHIFT + G : 함수를 호출하는 함수를 찾아준다.

 -. CTRL + ALT + H : 함수를 호출하는 함수를 찾아준다.(처음 호출해지는 함수까지 찾아준다.)




===== 실행 및 디버깅 =====

 -. Ctrl + Shift + B : 현 커서의 위치에 브레이크 포인터 설정/해제

 -. F11 : 디버깅 시작

 -. F8 : 디버깅 계속

 -. F6 : 한 줄씩 실행(Step Over)

 -. F5 : 한 줄씩 실행하되 함수일 경우 그 함수 내부로 들어감(Step Into)

 -. Ctrl + R : 현재 라인까지 실행(Run to Line)

 -. Ctrl + F11 : Run 파일 실행


  F12 : 에디터 활성화


===== 코드 템플릿 사용하기 =====

1. Class에 주석 넣기

   Window > Preferences > Java > Code Style > 
            Code Templates > Comments > Types > Edit 버튼 클릭

   내용 수정
   
/**
 * <pre>
 * ${package_name}
 * ${file_name}
 * </pre>
 *
 * @Author  : ${user}
 * @Date    : ${date}
 * @Version : 
 * ${tags}
 */ 




========================================================================================


Java SE : 
Java ME : Embedded Java
Java EE


Public Key        Private Key

http://tomcat.apache.org/


@ Codebook
마크다운 : //  =>  //:   

@ 가변 메소드
    static void sum(int... values) {
        int s = 0;
        for (int v : values) {
            s += v;
        }
        System.out.printf("합계: %d\n", s);
    }



        i = 4885223;
        int count = 0;
        int[] cnt = new int[10];
        while(i > 0) {
            cnt[i % 10]++;
            i /= 10;
        }
        
        int x = 0;
        while (x < cnt.length) {
            System.out.printf("%d = %d\n", x, cnt[x]);
            x++;
        }



=================================================================================


Java Window 프로그램


AWT

 |

Swing  + alpha  =>  SWT

 |


JavaFX












=============================================================================


@ 클래스 로딩되는 시점

// 1) 클래스 변수를 사용할 때 
//MyClass2.v1 = 200;

// 2) 클래스 메서드를 사용할 때 
//MyClass2.m1();

// 3) new 연산자를 사용할 때
//new MyClass2(); 
        
// 주의!
// => 레퍼런스 변수를 선언할 때는 클래스가 로딩되지 않는다.
// MyClass2 obj1 = null;


public class MyClass2 {
    // static member
    
    // 스태틱 변수 = 클래스 변수
    // => 클래스 이름으로 사용하고, 클래스에 소속된 변수라고 해서
    //    "클래스 변수"라 부른다.
    static int v1 = 100; // 스태틱 변수 = 클래스 변수
    static void m1() { // 스태틱 메서드 = 클래스 메서드
        System.out.println("MyClass2.m1()");
    }
    
    
    // instance member
    int v2 = 200; // 인스턴스 변수
    void m2() { // 인스턴스 메서드
        System.out.println("인스턴스.m2()");
    }
    
}

=======================================================================
// 스태틱 변수는 JVM 종료할 때 메모리에서 해제
// 스태틱 변수는 JVM 종료할 때 메모리에서 해제하기 때문에 메모리를 많이 차지
// 클래스 static 변수는 Method Area에 만들어진다.

// Heap에 있는 변수는 가비지 컬렉터가 메모리를 해제한다.

// new로 선언된 변수는 인스턴스변수는 무조건 Heap에 만들어진다.


// 그외는 Local 변수, 로컬에 선언된 레퍼런스 변수는 Stack에 만들어진다.






=======================================================================


// 스태틱 변수 스태틱 메서드 : 인스턴스 변수 인스턴스 메서드
package bitcamp.java100.ch06.ex6;

import bitcamp.java100.ch06.ex5.Score2;

public class Test9 {
    
    // main(static method) 함수에서 instance variable 사용 불가
    // static class 에서 instance variable 사용 가능
    int ginstvar;
    
    // main(static method) 함수에서 static variable 사용 가능
    // static class 에서 static variable 사용 가능
    static int gstatvar;
    
    // main(static method) 함수에서 instance method 호출 불가
    void ginstMethod() {
        // instance variable 사용 가능
        ginstvar += 100;
        
        // static variable 사용 가능
        gstatvar += 100;
        
        System.out.println("ginstMethod() ginstvar = " + ginstvar);
        System.out.println("ginstMethod() gstatvar = " + gstatvar);
        
        // instance method에서 static method 호출 가능
        gstatMethod();
        

        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classnaem.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    // main 함수에서 static method에서 호출 가능
    // static class에서 호출가능
    static void gstatMethod() {
        // static method에서 instance variable 사용 불가
        //ginstvar = 100;  // 컴파일 오류
        
        // static method에서 static variable 사용 가능
        gstatvar += 100;
        
        //System.out.println("ginstMethod() ginstvar = " + ginstvar);  // 컴파일 오류!
        System.out.println("gstatMethod() gstatvar = " + gstatvar);
        
        // static method에서 instance method 호출 불가
        //ginstMethod();  // 컴파일 오류!
        
        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    
    // ***********************************************************
    // non-public, non-static class 선언가능하나 사용할 수 없음
    //class NonStatClass {     // 사용할 수 없음
    //}
    // ***********************************************************
    
    
    static class StatClass {
        // instance variable 초기값은 '0'
        int instvar;

        // static variable 초기값은 '0'
        static int statvar;
        
        // instance method(non-static method)는 this를 내장하고 있다.
        void instMethod() {
            this.instvar += 100;
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            this.statvar += 100;
            
            // instance method 에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            //instMethod();
            // instance method 에서 static method 호출 가능
            statMethod();
            
            System.out.println("instMethod() instvar = " + this.instvar);
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            System.out.println("instMethod() statvar = " + this.statvar); 
        }
        
        // static method(class method) 에서 this 사용할 수 없다.
        static void statMethod() {
            // static method에서 instance 내장변수 this 사용 불가
            //this.instvar += 100;  // 컴파일 오류!
            //this.statvar += 100;  // 컴파일 오류!
            
            // static class에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            
            // static method에서 instance method 호출 불가
            //instMethod();  // 컴파일 오류!
            
            // static method에서 instance variable 사용 불가
            //instvar += 100;  // 컴파일 오류!
            
            // static method에서 static variable 사용 가능
            statvar += 100;
            
            // static method에서 instance variable 사용 불가
            //System.out.println("m2() instvar = " + instvar);  // 컴파일 오류
            System.out.println("m2() statvar = " + statvar);
        }
    }
    
    public static void main(String[] args) {
        //A a = null;
        
        // main(static method) 에서 instance variable / method 사용 불가
        //ginstvar += 100;   // 컴파일 오류!
        //ginstMethod();      // 컴파일 오류!
        
        // main(static method) 에서 static variable / method 사용 가능
        gstatvar += 100;
        gstatMethod();

        System.out.println("gstatvar = " + gstatvar);
        
        
        //######################################################################################
        // instance reference 변수 선언과 동시에 클래스(변수, 메서드)가 Method Area에 로딩된다.
        // Heap에 인스턴스 변수만 메모리 생성되고 인스턴스 메서드는 생성되지 않음.
        // (클래스 메서드 즉 Method Area에 있는 함수를 호출)
        //######################################################################################

        // 인스턴스은 클래스 메서드(Method Area)를 호출한다.   
        // static 붙은 메서드는 클래스명.메서드명()
        // static 없는 메서드는 인스턴스명.메서드명()
        
        // new를 사용해서 instance variable 를 계속 선언하면 힙에 계속해서 인스턴스 메모리가 생성
        StatClass statclass1 = new StatClass();
        StatClass statclass2 = new StatClass();
        

        // instance.instance 사용 가능
        statclass1.instvar += 100;
        statclass1.instMethod();
        
        System.out.println("statclass1.instvar = " + statclass1.instvar);

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass2.statvar += 100;
        statclass2.statMethod();
        
        System.out.println("statclass2.statvar = " + statclass2.statvar);
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!

        // classname.static 사용 가능
        StatClass.statvar += 100;
        StatClass.statMethod();
        
        System.out.println("StatClass.statvar = " + StatClass.statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        // 배열을 인스턴스로 정의해야 한다.
        StatClass[] statclass3 = new StatClass[3];
        statclass3[0] = new StatClass();
        statclass3[1] = new StatClass();
        statclass3[2] = new StatClass();
        
        // classarray.instance 사용 가능
        statclass3[0].instvar = 100;
        statclass3[0].instMethod();
        
        System.out.println("statclasss[0].instvar = " + statclass3[0].instvar);

        // classarray.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass3[0].statvar = 100;
        statclass3[0].statMethod();
        
        System.out.println("statclass3[0].statvar = " + statclass3[0].statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        StatClass[] statclass4 = new StatClass[3];

        statclass4[0] = statclass1;
        
        System.out.println("statclass4[0].instvar = " + statclass4[0].instvar);
        System.out.println("statclass4[0].instvar = " + statclass4[0].statvar);
    }
}



인스턴스는 배열을 만들지 못하고 레퍼런스 배열을 만든다.
레퍼런스 배열을 인스턴스한다.

static 변수는 this을 붙여도 되나 굳이 붙일 필요가 없다.

================================================================================



UML과 패턴의 적용   분석 설계


The Art of Computer Programming    도널드 커누스


https://github.com/samchon?tab=repositories



























