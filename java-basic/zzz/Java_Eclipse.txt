엄진영 강사 : 010-2634-4150   test   1


환경변수 설정 => C:\Program Files\Java\jdk-9\bin;

   (Parentheses:Round Bracket)    [Square Bracket]    <Angle Bracket>    {Brace}

JAVA_HOME : C:\Program Files\Java\jdk-9

Path  : C:\Program Files\Java\jdk-9\bin;C:\gradle-4.2\bin;C:\cygwin64\usr\include;C:\cygwin64\bin;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\64bit\;c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;C:\Program Files\nodejs\;C:\Program Files\Git\cmd;C:\gradle-4.2\bin



@ 이클립스설치

  - Eclipse IDE for Java EE Developers 설치



@ 이클립스에서 jdk9 실행 설정

1) eclipse.ini  수정

C:\Users\bit-user\eclipse\jee-oxygen 에서 eclipse.ini  수정


-Dosgi.requiredJavaVersion=1.8
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication

-Dosgi.requiredJavaVersion=1.8



-Dosgi.requiredJavaVersion=9       =====>  수정
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication
--add-modules=ALL-SYSTEM           =====>  추가
-Dosgi.requiredJavaVersion=9       =====>  수정


2) jdk9 설치 확인

Help  =>  Elclipse Martketplace 에서 Java 9 검색해서 Java 9 Support for Oxygen 4.7 설치

Perferences  =>  Java  =>  Installed JREs  =>  Add 버튼 클릭 =>  Standard VM 선택  
             =>  Next 버튼 클릭 =>  JRE home에서 => Diretory 버튼 클릭해서 jdk-9 폴더 선택


- Java jdk9 설치 확인
- eclipse jdk9 검색



@ workspace 에러 발생할 경우 폴더 이름 변경후 소스 파일 복사
   An error has occured. See the log file
   C:\Users\User\elcipse-workspace\.metadata\.log


@ Run 할때 에러 메시지 처리 :  
 # Exception in thread "main" java.lang.Error: Unresolved compilation problem:
   - Bin 폴더 삭제
   - Projcet => Clean



@ Preferences 설정 

General  =>  Apperance  =>  Theme  =>  Dark

General  =>  Apperance  =>  Colors and Font  =>  Basic  =>  Edit Text
             : 기본 Console Font
             => D2Coding

General => Content Types => Java Class File => Default encoding => UTF-8 => Update

General  =>  Editors  =>  Text Editors
    
             Insert space for tabs
             Show print margin
             Show line numbers
             Show whitespace charaters   Carriage Return, Line Feed 체크 해제
                                         Transparency level( . 투명도)

General => Editors => Text Editors => Spelling => Encoding => Default(UTF-8)

General =>  Workspace  =>  Text file encoing   Other UTF-8 설정

Java  =>  Code Style  =>  Formatter  =>  New 클릭 my 입력후 OK 클릭
                                         Tab policy에서  Spaces only 설정


Web  =>   CSs Files/Htm Files/JSP Files  =>  UTF-8 설정



폰트 d2coding 사용 
  https://github.com/naver/d2codingfont/releases
  "C:\Windows\Fonts\" 경로에 복사

  크롬 기본 글꼴 : 맞춤
  익스플로어 기본 글꼴 : 웹 페이지 글꼴(Gulim), 일반 텍스트 글꼴(GulimChe)



@ View 초기화
  Window => Perspective  => Open Perspective  => Other  => Java EE

@ Eclipse에서 Project Explorer / Navigator  /  Outline / Task List
  Window  =>  Show View  =>  Other  에서 맨위에서 검색






@ Project Import Gradle 사용


1) gradle 명령어 모음

build.gradle             https://docs.gradle.org/4.2.1/userguide/eclipse_plugin.html

apply plugin: 'eclipse'


java-basic> gradle init --type java-application


java-basic> gradlew tasks --all


java-basic> gradlew EclipseProject


java-basic> gradlew cleanEclipseProject


java-basic> gradlew EclipseClasspath


java-basic> gradlew cleanEclipseProject


java-basic> gradlew Eclipse


java-basic> gradlew cleanEclipse




2) build.gradle 수정해서 jdk9으로 설정


apply plugin: 'eclipse'


eclipse {
  jdt {
    //if you want to alter the java versions (by default they are configured with gradle java plugin settings):
    sourceCompatibility = 9
    targetCompatibility = 9
    javaRuntimeName = "JavaSE-9"

    file {
      whenMerged { jdt
      }

      withProperties { properties ->
        properties["org.eclipse.jdt.core.compiler.codegen.targetPlatform"] = "9"
        properties["org.eclipse.jdt.core.compiler.source"] = "9"
        properties["org.eclipse.jdt.core.compiler.compliance"] = "9"
      }
    }
  }
}


3) gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

java-basic> gradlew cleanEclipse

java-basic> gradlew Eclipse


- C:\Users\bit-user\git\bitcamp\java-basic 폴더에서 .classpath 파일에서 JavaSE-9 설정 확인
  	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/
         org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-9/"/>

- C:\Users\bit-user\git\bitcamp\java-basic\.settings 폴더에서 org.eclipse.jdt.core.prefs 확인
  org.eclipse.jdt.core.compiler.codegen.targetPlatform=9
  org.eclipse.jdt.core.compiler.source=9
  org.eclipse.jdt.core.compiler.compliance=9


4) eclipse 에 Import

File => Import => General => Existing Projects into WorkSpace => Browse(폴더선택)
        - Select root directory : 압축 해제된 프로젝트 폴더
        - Select archive file   : 압축 상태인 프로젝트 압축파일



5) Import 에러

  오류: 기본 클래스 bitcamp.java100.Test16_1을(를) 찾거나 로드할 수 없습니다.
  원인: java.lang.ClassNotFoundException: bitcamp.java100.Test16_1

  Project Context Menu => Proerties => Java Build Path 에서 jar 경로확인
  git에서 다운 받았기 때문에 Users 가 bit-user로 되어 있음
  노트북은 Users 가 user로 되어 있음

  gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse

  한 후 다시 Import 한다.


6) Import 의 Project 명이 폴더명과 다른경우(다른 폴더 복사했을 경우)

  - settings.gradle 파일에서 rootProject.name 변경

    rootProject.name = 'bitcamp-java-basic' => rootProject.name = 'java-basic'

  - .project 파일에서 <projectDescription> 변경
 
    <name>bitcamp-java-basic</name>  =>  <name>java-basic</name>


7) Synchronize gradle projects with workspace failed due to an error configuring eclipse

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse


8) Project 오른쪽 마우스(context menu)  >  Properties > Java Compiler => Version 확인
   
   





@@ Eclipse에서 Git 사용


@ Git Push 및 Pull

  Window  =>  Show View  =>  Other  =>  Git Repositories
  Window  =>  Show View  =>  Other  =>  Git Staging

  Git Repoitories 에서 해당 git에서 오른쪽 Context Menu  =>  Push to Stream

  Git Staging 에서 Unstaged Changes 에서 Staged Changes 로 파일 이동하고
  Commit Message에 메시지 입력

  Commit and Push 클릭해서 로그인

  한번 Commit 하면 이클립스 다시 실행





@ Eclipse에서 Git 자동로그인 해제

  Window  =>  Preference  =>  General  =>  Security  =>  Secure Storage  =>  Contents Tab에서 삭제





 @ 단축키 등록 보기   [Ctrl + Shift + L]



========================= 기타 설정 ==============================
     
 @ 단축키 등록

 -. Window > Preference > General > Keys > Command에서 File Search 이동 > 
    
    Binding 에 원하는 단축키 클릭 / In Windows > Apply

 
 @ 자동 완성 설정 해제

 -. 자동 완성 해제

    Windows > Preferences > Java > Editor > Content Assist > Enable auto activation : 

 -. 컨텐트 어시트 해제되어 있어도 Ctrl + Space하면 컨텐트 어시트 나타남

 
 @ 괄호 자동 완성 해제

 -. Windows > Preferences > Java > Editor > Typing > Automatically close


========================= 소스 네비게이션 =========================

 -. window > New Window  :  이클립스 새창

 -. Ctrl + M : 현재 활성화된 뷰나 에디터 최대화
 -. Ctrl + F6 : 소스간 이동
 -. Ctrl + F7 : 뷰간 이동 ( 에디터 최대창에서 Project Explorer 창 보인)
 -. Ctrl + F8 : 다음 Perspective로 이동(Debug, JavaEE)

 -. Ctrl + PageUp, Ctrl + PageDown : 소스탭 이동



========================= 소스 코드 편집 =========================


 -. 상위 주석 펼치기 : Window > Preference > Java > Folding > Header Comments


 -. F3(Ctrl + 마우스커서) : 선언된 변수로 이동, 메소드 정의부로 이동
 -. F4         : 클래스명을 선택하고 누르면 해당 클래스의 Hierarchy 를 볼 수 있다.

 -. Ctrl + O   : 해당 소스의 메소드 리스트를 확인하려 할때
 -. Ctrl + Shift + Down : Java Editor에서 다음 member로 이동

 -. Ctrl + Space       :  컨텐트 어시스트

 -. Ctrl + Shift + M : 특정 클래스 Import
 -. Ctrl + Shift + O : 자동으로 Import

 -. Ctrl + Shift + F : 전체 코드 자동 정리 
 -. Ctrl + I : 선택 블록 코드 자동 정리


 -. Ctrl + Shift + W : 에디터창 모두 닫기 
 -. Alt + Q  : 에디터창 모두 닫기(단축키 개인 등록, In Windows)
 -. Alt + Z  : 현재 에디터창 제외 모두 닫기(단축키 개인 등록, In Windows)

 -. Ctrl + /           :  주석 토글
 -. Ctrl + Shift + /   :  블록 주석 추가
 -. Ctrl + Shift + \   :  블록 주석 삭제



 -. Alt + Left / Right Arrow  : 이전 소스 위치로 커서 이동
 -. Alt + Up / Down Arrow   : 선택한 소스 위치 변경


 -. Ctrl + Left / Right Arrow  : 문자열 이동
 -. Ctrl + Shift + Left / Right Arrow  : 문자열 선택
 -. Shift + Alt + Left / Right Arrow : 블록 선택 (Up/ Down은 다른 기능)


 -. Shift + Alt + a : 블록 복사 => 마우스가 십자가로 바뀜


 -. Ctrl + F : 현재 파일에서 특정 문자를 찾거나 찾은 문자를 교체하는 방법

 -. Ctrl + Shift + R : 프로젝트에 포함된 리소스(여기서는 파일)중에 찾는 방법

 -. Ctrl + Shift + G : 현재 패키지에 함수를 호출하는 위치를 모두 찾아준다.



 -. Ctrl + H 단축키를 Open Search Dialog을 File Search로 변경 : 단축키 변경관 같음
    
    Open Search Dialog 기본 정보 : Binding(Ctrl + H), When(In Windows)
    


========================= 실행 및 디버깅 =========================

 -. Ctrl + Shift + B : 현 커서의 위치에 브레이크 포인터 설정/해제

 -. F11 : 디버깅 시작

 -. F8 : 디버깅 계속

 -. F6 : 한 줄씩 실행(Step Over)

 -. F5 : 한 줄씩 실행하되 함수일 경우 그 함수 내부로 들어감(Step Into)

 -. Ctrl + R : 현재 라인까지 실행(Run to Line)

 -. Ctrl + F11 : Run 파일 실행


 -. F12 : 에디터 활성화

 -. F12 : 컴파일 중 에러등으로 포커스가 다른데로 갔을 때 Editor 로 커서 이동


========================= 코드 템플릿 사용하기 =========================

1. Class에 주석 넣기

   Window > Preferences > Java > Code Style > 
            Code Templates > Comments > Types > Edit 버튼 클릭

   내용 수정
   
/**
 * <pre>
 * ${package_name}
 * ${file_name}
 * </pre>
 *
 * @Author  : ${user}
 * @Date    : ${date}
 * @Version : 
 * ${tags}
 */ 


========================= Refactoring =========================
    

 @ Setters and Getters 자동 추가

    Content Menu > Source > Generate Setters and Getters


 @ Super Class 만들기

   Content Menu > Refactor > Extract SuperClass  => Generalization

 
 @ 기본 Overiding 만들기

   클래스 파일에서 Ctrl + Space 한 후 오버라이딩할 메서드 선택


 @ toString(), hashCode(), equals() 오버라이딩 만들기

   Content Menu > Source > Generate toString()

   Content Menu > Source > Generate hashCode() and equals()

   


================================================================


Java SE : 
Java ME : Embedded Java
Java EE


Public Key        Private Key

http://tomcat.apache.org/


@ Codebook
마크다운 : //  =>  //:   

@ 가변 메소드
    static void sum(int... values) {
        int s = 0;
        for (int v : values) {
            s += v;
        }
        System.out.printf("합계: %d\n", s);
    }



        i = 4885223;
        int count = 0;
        int[] cnt = new int[10];
        while(i > 0) {
            cnt[i % 10]++;
            i /= 10;
        }
        
        int x = 0;
        while (x < cnt.length) {
            System.out.printf("%d = %d\n", x, cnt[x]);
            x++;
        }



=================================================================================


@ Java Window 프로그램


        AWT

         |

  Swing  + alpha  =>  SWT

         |

       JavaFX



=============================================================================


@ 클래스 로딩되는 시점

// 1) 클래스 변수를 사용할 때 
//MyClass2.v1 = 200;

// 2) 클래스 메서드를 사용할 때 
//MyClass2.m1();

// 3) new 연산자를 사용할 때
//new MyClass2(); 
        
// 주의!
// => 레퍼런스 변수를 선언할 때는 클래스가 로딩되지 않는다.
// MyClass2 obj1 = null;


public class MyClass2 {
    // static member
    
    // 스태틱 변수 = 클래스 변수
    // => 클래스 이름으로 사용하고, 클래스에 소속된 변수라고 해서
    //    "클래스 변수"라 부른다.
    static int v1 = 100; // 스태틱 변수 = 클래스 변수
    static void m1() { // 스태틱 메서드 = 클래스 메서드
        System.out.println("MyClass2.m1()");
    }
    
    
    // instance member
    int v2 = 200; // 인스턴스 변수
    void m2() { // 인스턴스 메서드
        System.out.println("인스턴스.m2()");
    }
    
}

===================== 메모리 생성 및 해제 =============================


 클래스 static 변수는 Method Area에 생성된다.


 스태틱 변수는 JVM 종료할 때 메모리에서 해제
 스태틱 변수는 JVM 종료할 때 메모리에서 해제하기 때문에 메모리를 많이 차지


 new로 선언된 변수는 인스턴스변수는 무조건 Heap에 만들어진다.
 Heap에 있는 변수는 가비지 컬렉터가 메모리를 해제한다.


 그외는 Local 변수, 로컬에 선언된 레퍼런스 변수는 Stack에 만들어진다.


 인스턴스는 배열을 만들지 못하고 레퍼런스 배열을 만든다.

 클래스 배열을 정의(StatClass[] statclass3 = new StatClass[3];) 하면 statck 메모리에 생성

 메서드만 사용할 경우 인스턴스 변수( statclass3[0] = new StatClass(); )를 선언하지 않아도 된다.

 statclass3[0] = new StatClass(); 정의하면 instance 메모리에 배열의 값이 저장될 인스턴스 메모리가 생성된다.



 static 변수는 this을 붙여도 되나 굳이 붙일 필요가 없다.



=======================================================================


// 스태틱 변수 스태틱 메서드 : 인스턴스 변수 인스턴스 메서드
package bitcamp.java100.ch06.ex6;

import bitcamp.java100.ch06.ex5.Score2;

public class Test9 {
    
    // main(static method) 함수에서 instance variable 사용 불가
    // static class 에서 instance variable 사용 가능
    int ginstvar;
    
    // main(static method) 함수에서 static variable 사용 가능
    // static class 에서 static variable 사용 가능
    static int gstatvar;
    
    // main(static method) 함수에서 instance method 호출 불가
    void ginstMethod() {
        // instance variable 사용 가능
        ginstvar += 100;
        
        // static variable 사용 가능
        gstatvar += 100;
        
        System.out.println("ginstMethod() ginstvar = " + ginstvar);
        System.out.println("ginstMethod() gstatvar = " + gstatvar);
        
        // instance method에서 static method 호출 가능
        gstatMethod();
        

        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classnaem.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    // main 함수에서 static method에서 호출 가능
    // static class에서 호출가능
    static void gstatMethod() {
        // static method에서 instance variable 사용 불가
        //ginstvar = 100;  // 컴파일 오류
        
        // static method에서 static variable 사용 가능
        gstatvar += 100;
        
        //System.out.println("ginstMethod() ginstvar = " + ginstvar);  // 컴파일 오류!
        System.out.println("gstatMethod() gstatvar = " + gstatvar);
        
        // static method에서 instance method 호출 불가
        //ginstMethod();  // 컴파일 오류!
        
        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    
    // ***********************************************************
    // non-public, non-static class 선언가능하나 사용할 수 없음
    //class NonStatClass {     // 사용할 수 없음
    //}
    // ***********************************************************
    
    
    static class StatClass {
        // instance variable 초기값은 '0'
        int instvar;

        // static variable 초기값은 '0'
        static int statvar;
        
        // instance method(non-static method)는 this를 내장하고 있다.
        void instMethod() {
            this.instvar += 100;
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            this.statvar += 100;
            
            // instance method 에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            //instMethod();
            // instance method 에서 static method 호출 가능
            statMethod();
            
            System.out.println("instMethod() instvar = " + this.instvar);
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            System.out.println("instMethod() statvar = " + this.statvar); 
        }
        
        // static method(class method) 에서 this 사용할 수 없다.
        static void statMethod() {
            // static method에서 instance 내장변수 this 사용 불가
            //this.instvar += 100;  // 컴파일 오류!
            //this.statvar += 100;  // 컴파일 오류!
            
            // static class에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            
            // static method에서 instance method 호출 불가
            //instMethod();  // 컴파일 오류!
            
            // static method에서 instance variable 사용 불가
            //instvar += 100;  // 컴파일 오류!
            
            // static method에서 static variable 사용 가능
            statvar += 100;
            
            // static method에서 instance variable 사용 불가
            //System.out.println("m2() instvar = " + instvar);  // 컴파일 오류
            System.out.println("m2() statvar = " + statvar);
        }
    }
    
    public static void main(String[] args) {
        //A a = null;
        
        // main(static method) 에서 instance variable / method 사용 불가
        //ginstvar += 100;   // 컴파일 오류!
        //ginstMethod();      // 컴파일 오류!
        
        // main(static method) 에서 static variable / method 사용 가능
        gstatvar += 100;
        gstatMethod();

        System.out.println("gstatvar = " + gstatvar);
        
        
        //######################################################################################
        // instance reference 변수 선언과 동시에 클래스(변수, 메서드)가 Method Area에 로딩된다.
        // Heap에 인스턴스 변수만 메모리 생성되고 인스턴스 메서드는 생성되지 않음.
        // (클래스 메서드 즉 Method Area에 있는 함수를 호출)
        //######################################################################################

        // 인스턴스은 클래스 메서드(Method Area)를 호출한다.   
        // static 붙은 메서드는 클래스명.메서드명()
        // static 없는 메서드는 인스턴스명.메서드명()
        
        // new를 사용해서 instance variable 를 계속 선언하면 힙에 계속해서 인스턴스 메모리가 생성
        StatClass statclass1 = new StatClass();
        StatClass statclass2 = new StatClass();
        

        // instance.instance 사용 가능
        statclass1.instvar += 100;
        statclass1.instMethod();
        
        System.out.println("statclass1.instvar = " + statclass1.instvar);

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass2.statvar += 100;
        statclass2.statMethod();
        
        System.out.println("statclass2.statvar = " + statclass2.statvar);
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!

        // classname.static 사용 가능
        StatClass.statvar += 100;
        StatClass.statMethod();
        
        System.out.println("StatClass.statvar = " + StatClass.statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        // 배열을 인스턴스로 정의해야 한다.
        StatClass[] statclass3 = new StatClass[3];  // 객체 주소를 저장할 Stack 메모리 생성
        statclass3[0] = new StatClass();            // 데이터를 저장할 Heap 메모리 생성 
        statclass3[1] = new StatClass();
        statclass3[2] = new StatClass();
        
        // classarray.instance 사용 가능
        statclass3[0].instvar = 100;
        statclass3[0].instMethod();
        
        System.out.println("statclasss[0].instvar = " + statclass3[0].instvar);

        // classarray.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass3[0].statvar = 100;
        statclass3[0].statMethod();
        
        System.out.println("statclass3[0].statvar = " + statclass3[0].statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        StatClass[] statclass4 = new StatClass[3];

        // statclass1의 주소를 statclass4[0] 에 저장
	// statclass4[0] = new StatClass(); 가 필요 없다.
        statclass4[0] = statclass1;  
        
        System.out.println("statclass4[0].instvar = " + statclass4[0].instvar);
        System.out.println("statclass4[0].instvar = " + statclass4[0].statvar);
    }
}





================================== 클래스 생성자 =============================================
        

 @ 생성자 : 메모리를 만든후 최소한의 상태를 만드는것

   - 인스턴스를 사용 가능하도록 유효한 상태로 만드는 것

   - 즉 변수의 초기값 설정과 배열의 초기 상태을 만들기 위해서 사용


   - 생성자는 클래스명과 같다(생략 가능하며, 컴파일러가 자동 추가)
     classname () {}

   - 수퍼클래스의 생성자(생략 가능하며, 컴파일러가 자동 추가)
     super();
  

    //생성자 : 메모리를 만든후 최소한의 상태를 만드는것
    //즉 배열의 초기 상태을 만듬

    Score() {
     this.subjects = new int[3];
    }
    
    
    Score(String name, int kor, int eng, int math) {  // 가변 파라미터
     this.name = name;        // this.name(instance variable) 과 name(local variable, method parameter)
     //this.subjects[0] = kor;
     //this.subjects[1] = eng;
     //this.subjects[2] = math;
     
     this.subjects = new int[] {kor, eng, math}; // 초기값 할당과 구분
     
     this.compute();
    }



================================== 클래스 상속(Inheritance) ====================================


  class 클래스명 extends 기존클래스명 {...}

  상속을 해주는 클래스를 "수퍼(super)/부모(parent) 클래스"라고 부른다.

  상속을 받는 클래스를 "서버(sub)/자식(child) 클래스"라고 부른다.

  최상위 수퍼클래스는 Object 클래스이다.

  기존 클래스의 링크 정보를 등록하여 수퍼클래스의 멤버(필드, 메서드)를 상속 받는다.

  수퍼클래스의 멤버(변수, 메서드)를 상속받아 새로운 변수 및 기능을 추가한다.

  수퍼클래스 코드에 문제가 있으면 그 코드를 수정하면 즉시 서브 클래스들은 수정된 코드를 사용하게 된다.

  
  @ 상속의 종류

    1) Specialization

       - 수퍼 클래스를 상속 받아 기능을 추가하여 더 특별한 서브 클래스를 만드는 것.

    2) Generalization

       - 서브 클래스들의 공통 변수나 공통 메서드를 추출하여 수퍼 클래스를 정의하는 것.

       - Content Menu > Refactor > Extract SuperClass  => Generalization



================================== 클래스 캡슐화(Encapsulation) ================================


 클래스 멤버(필드, 메서드)에 접근을 제어하는 기법

 - public    : 같은 패키지와 다른 패키지에 모두 공개
 - protected : 같은 패키지와 다른 패키지에 있는 자손 클래스에게 공개
 - (default) : 같은 패키지에 소속된 클래스에게만 공개
 - private   : 비공개


 - 패키지 멤버 클래스는 public, default 만 가능하며, 
   패키지에 선언되었기 때문에 같은 패키지만 공개하면 된다.


 - 클래스 안에 선언된 클래스를 "중첩(nested) 클래스"라 부른다.

 - 캡슐화의 존재 이유 : 인스턴스 변수에 무효한 값이 저장되는 것을 방지함으로써 추상화가 무너지는 것을 막는다.

 - 추상화(Abstraction) : 사물이나 사람, 업무 등을 데이터와 메서드로 표현하는 것

 - 필드(주로 값의 입력)를 접근 제한하면 필드의 값을 설정하는 메서드(Setter, Getter)는 전체 공개를 해야하고, 
   외부에서 필요없는 메서드(계산처리)는 접근 제한한다.
  


=============================== 다형적 변수 (Polymorphism) ========================================

 수퍼 클래스의 레퍼런스는 서브 클래스의 인스턴스를 주소를 저장할 수 있다.

 서브 클래스의 인스턴스는 무조건 수퍼 클래스의 인스턴스를 모두 갖고 있기 때문이다.

 이렇게 상속 관계에 따라 한 레퍼런스에 다양한 클래스의 객체 주소를 저장할 수 있다고 해서 "다형적 변수" 라고 부른다.

 구체적인 타입을 지정하기 보다는 그것의 상위 타입을 지정함으로써 
 그 자리에 다양한 타입의 객체를 넣을 수 있다.
 
 public class Car extends Vehicle {}
 public class Truck extends Car {}
 c = new Car();
 c = new Truck();  // Car의 멤버를 사용할 수 있다.

 Sedan c2 = (Sedan)c;  // 명시적 형변환을 해주면 Car의 멤버를 사용할 수 있다.



======================= 오버라이딩 Overrigind(Polymorphism) =====================================


@ 오버라이딩의 메서드 호출

  수퍼클래스의 메서드를 상속받아 메서드 기능을 재정의

  @Override을 메서드명 앞에 붙여 에러를 방지한다.


  오버라이딩 규칙 
    => 접근 범위 : 같거나 확장 (private < default < protected < public)
    => 접근 범위 축소하면 컴파일 오류

    => 리턴 타입 : 반드시 일치
    => 메서드명  : 반드시 일치
    => 파라미터 타입 및 개수 및 순서 : 반드시 일치
    => 파라미터명 : 상관없음

    => 메서드명은 같지만 파라미터의 타입이 다르거나 갯수, 순서가 다른 경우 새 메서드를 추가한것
  

  현재 클래스에 메서드가 정의되었는지 확인하고, 없으면 수퍼 클래스에서 정이 되었는지 확인
  this.compute();   


  현재 클래스가 아니라 수퍼클래스에서 정의되었는지 확인
  super.compute();



  오버라이딩 된 메서드는 호출되는 것은 클래스의 인스턴스 주소에 따라서 결정


  HashSet은 ArrayList 나 MashMap, HashTable 처럼 객체의 주소를 보관

  HashSet는 개체의 주소를 중복해서 보관하지 않는다.


  Object에서 상속받은 toString(), hashCode(), equals() 함수를 오버라이딩 해서 사용
  
  toString() : 인스턴스 변수의 값을 확인

  hashCode(), equals() : 인스턴스의 변수의 값이 같은지 확인


  StringBuffer는 equals()를 재정의하지 않았기 때문에 Object의 equals()를 그대로 사용한다.

  hash값 : 각 인스턴스를 구분할 때 사용할 디지털 지문!



========================= 오버로딩 Overloading(Polymorphism) =================================


  파라미터의 갯수, 타입, 순서가 다르더라도 같은 기능을 수행하는 메서드에 
  같은 이름을 부여하여 사용할 수 있게하는 문법

  메서드 호출 구분은 갯수, 타입, 순서로 구분한다. 

  리턴 값을 받느냐 안 받느냐로 호출할 메서드를 구분할 수 없다.

  리턴 타입만 다른 메서드는 추가할 수 없고, 파라미터의 갯수, 타입, 순서가 다르게 해야한다.

  파라미터 타입이 메서드와 다를 때는 암시적 타입 캐스팅으로 가능한 메서드를 호출한다.

  수퍼 클래스에서 상속 받은 메서드와 이름은 같지만 파라미터가 다른 메서드를 추가하면 오버로딩이다.




======================================= 제네릭(Generic) =====================================

  제테릭이 적용된 클래스를 사용하면 여러 개의 클래스를 만들 필요가 없이

  하나의 클래스로 여러 타입의 객체를 사용할 수 있다.


  제네릭을 사용하는 이유는 타입의 안정성을 제공하고, 타입체크와 형변환을 생략하여 코드가 간결하다.

  선언할 수 있는 타입은 객체 타입과, wrapper(primitive 변수의 객체) 클래스만 가능하다


  클래스가 어떤 데이터 타입을 사용할 것인지 타입명을 받는다
  
  Type의 약자인 T를 주로 사용

  E - Element (used extensively by the Java Collections Framework)
  K - Key
  N - Number
  T - Type
  V - Value
  S,U,V etc. - 2nd, 3rd, 4th types


  Stack<Contact> contacts = new Stack<>();
  contacts.push(new Contact("홍길동", "hong@test.com", "1111-1111"));  // Contact 생성자

  public class Stack<T> {
    
    // 그리고 사용자가 전달한 타입의 이름을 코드 곳곳에 지정하면 된다.
    private class Box {
        T value;
        Box next;
        
        public Box() {}
        
        public Box(T value) {
            this.value = value;
        }
    }
    
    public void push(T value) {
        // 새 상자를 만들어 값을 저장한다.
        Box box = new Box(value);
    }
  }



=========================== @SuppressWarnings Annotation ========================================

  

    @SuppressWarnings("unchecked")
    T get(int index) {
        if (index < 0 || index >= this.cursor) {
            return null;
        }
        return (T)this.list[index];
    }

    return (T)this.list[index]; => 
      => 제네릭 하면서 타입 캐스팅에 확신이 없을 때 
         커서를 소스위에 올리고(단축키 F2)  add @SuppressWarnings("unchecked") 추가


    1. all : 모든 경고를 억제
    2. cast : 캐스트 연산자 관련 경고 억제
    3. dep-ann : 사용하지 말아야 할 주석 관련 경고 억제
    4. deprecation : 사용하지 말아야 할 메소드 관련 경고 억제
    5. fallthrough : switch문에서의 break 누락 관련 경고 억제
    6. finally : 반환하지 않는 finally 블럭 관련 경고 억제
    7. null : null 분석 관련 경고 억제
    8. rawtypes : 제네릭을 사용하는 클래스 매개 변수가 불특정일 때의 경고 억제
    9. unchecked : 검증되지 않은 연산자 관련 경고 억제
    10. unused : 사용하지 않는 코드 관련 경고 억제



======================================= 컬렉션 프레임워크 =====================================

  컬렉션즈 프래임워크라는 것은 다른 말로는 컨테이너라고도 부른다. 
  즉 값을 담는 그릇이라는 의미이다. 그런데 그 값의 성격에 따라서 컨테이너의 성격이 조금씩 달라진다. 
  자바에서는 다양한 상황에서 사용할 수 있는 다양한 컨테이너를 제공하는데 
  이것을 컬렉션즈 프래임워크라고 부른다.

  
  List : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
         ArrayList, LinkedList, Stack, Queue


  Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
        HashSet, TreeSet


  Map : 키와 값의 쌍으로 이루어진 데이터의 집합. 
        순서는 유지되지 않으며, 키는중복을 허용하지 않고, 값을 중복을 허용한다. 
        HashMap, Hashtable, TreeMap,
   
  toArray
        값을 배열로 꺼내고 싶다면, 값을 모두 담을 수 있는 배열을 만든 다음에,
        toArray()의 파라미터로 배열 주소를 넘겨라!
        그러면 배열에 객체들의 주소를 담아줄 것이다.
        만약 파라미터로 제공된 배열을 크기가 HashSet에 보관된 객체들의 수 보다 작다면,
        따로 배열을 새로 만든 다음에 그 배열의 주소를 리턴할 것이다.
	
        HashSet<String> set = new HashSet<>();

        String[] arr1 = new String[set.size()];
        String[] arr2 = set.toArray(arr1);

        String[] arr = set.toArray(new String[set.size()]);


        // ArrayList
        Iterator<String> iterator = list.iterator();
        

        // HashSet
        Iterator<String> iterator = set.iterator();


        // HashMap
        Iterator<Contact> iterator = map.values().iterator();

    
        // 값 출력
        while(iterator.hasNext()) {
            System.out.println(iterator.next());
        }



     arr[cursor++] = 80;   // Auto_Boxing => new Integer(80)




===================== 이터레이터(Iterator) 인터페이스 객체 ==========================

- 모든 컬렉션(Collection)으로 부터 정보를 얻을 수 있는 인터페이스 입니다.

  public interface Iterator {
    boolean hasNext();
    Object next();
    void remove();
  }



출처: http://vaert.tistory.com/108 [Vaert Street]






  Iterator<제네릭 타입> interator = list.iterator();

  ex) List 계열, Set 계열
      ArrayList<Score> list = new ArrayList<>();
      Iterator<Score> iterator = list.iterator();

     
  ex) Map 계열
      HashMap<String, Contact> map = new HashMap<>();
      Iterator<Contact> iterator = map.values().iterator();

      while(iterator.hasNext()) {
          System.out.println(iterator.next());
          iterator.remove();
      }






UML과 패턴의 적용   분석 설계


@ UML(Unified Modeling Language)

다른 사람들과의 의사소통 또는 설계 논의
전체 시스템의 구조 및 클래스의 의존성 파악
유지보수를 위한 설계의 back-end 문서

UML: 클래스 다이어그램과 소스코드 매핑 http://www.nextree.co.kr/p6753/




The Art of Computer Programming    도널드 커누스


https://github.com/samchon?tab=repositories


http://blog.eairship.kr/116


http://www.e-cartouche.ch/content_reg/cartouche/formats/en/html/Browser_learningObject1.html



@ 알고리즘 사이트
https://visualgo.net/en

@ 사이트 이동 경로 : breadcrumb

@ cache = Pooling 기법  = Lighting weight


@ 가상 머신 OS별 이미지
http://www.osboxes.org


@ Design Pattern : Best Practice, Gang of Four




















