엄진영 강사 : 010-2634-4150  


환경변수 설정 => C:\Program Files\Java\jdk-9\bin;

   (Parentheses:Round Bracket)    [Square Bracket]    <Angle Bracket>    {Brace}

JAVA_HOME : C:\Program Files\Java\jdk-9

Path  : C:\Program Files\Java\jdk-9\bin;C:\gradle-4.2\bin;C:\cygwin64\usr\include;C:\cygwin64\bin;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\64bit\;c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;C:\Program Files\nodejs\;C:\Program Files\Git\cmd;C:\gradle-4.2\bin




JAVA_HOME :  C:\Program Files\Java\jdk1.8.0_144

%JAVA_HOME%\bin;C:\gradle-4.2\bin;C:\cygwin64\usr\include;C:\cygwin64\bin;C:\oraclexe\app\oracle\product\11.2.0\server\bin;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\64bit\;c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;C:\Program Files\nodejs\;C:\Program Files\Git\cmd




@ 이클립스설치

  - Eclipse IDE for Java EE Developers 설치



@ 이클립스에서 jdk9 실행 설정

1) eclipse.ini  수정

C:\Users\bit-user\eclipse\jee-oxygen 에서 eclipse.ini  수정


-Dosgi.requiredJavaVersion=1.8
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication

-Dosgi.requiredJavaVersion=1.8



-Dosgi.requiredJavaVersion=9       =====>  수정
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication
--add-modules=ALL-SYSTEM           =====>  추가
-Dosgi.requiredJavaVersion=9       =====>  수정


2) jdk9 설치 확인

Help  =>  Elclipse Martketplace 에서 Java 9 검색해서 Java 9 Support for Oxygen 4.7 설치

Perferences  =>  Java  =>  Installed JREs  =>  Add 버튼 클릭 =>  Standard VM 선택  
             =>  Next 버튼 클릭 =>  JRE home에서 => Diretory 버튼 클릭해서 jdk-9 폴더 선택


- Java jdk9 설치 확인
- eclipse jdk9 검색



@ workspace 에러 발생할 경우 폴더 이름 변경후 소스 파일 복사
   An error has occured. See the log file
   C:\Users\User\elcipse-workspace\.metadata\.log


@ Run 할때 에러 메시지 처리 :  
 # Exception in thread "main" java.lang.Error: Unresolved compilation problem:
   - Bin 폴더 삭제
   - Projcet => Clean



@ Console 한글 깨질 경우

  -. cmd 에서 java -version 확인
  -. 환경변수에서 JAVA-HOME 확인 =>  C:\Program Files\Java\jdk1.8.0_144
  -. 환경변수에서 path 에서 확인 =>  %JAVA_HOME%\bin;
  -. eclipse 폴더에서 eclipse.ini 에서 자바 버전 확인  =>  --add-modules=ALL-SYSTEM 삭제
  -. Window > Preference > Java > Installed JREs 에서 jdk1.8.0_144 확인

  -. Project > Context Menu > Properties > Java Build Path > Libraries Tab 클릭 > 
     > JRE System Library [jdk1.8.0_144] 더블클릭 > Alternate JRE에서 jdk1.8.0_144 를 선택



@ Preferences 설정 

General  =>  Apperance  =>  Theme  =>  Dark

General  =>  Apperance  =>  Colors and Font  =>  Basic  =>  Edit Text
             : 기본 Console Font
             => D2Coding

General => Content Types => Java Class File => Default encoding => UTF-8 => Update

General  =>  Editors  =>  Text Editors
    
             Insert space for tabs
             Show print margin
             Show line numbers
             Show whitespace charaters   Carriage Return, Line Feed 체크 해제
                                         Transparency level( . 투명도)

General => Editors => Text Editors => Spelling => Encoding => Default(UTF-8)

General =>  Workspace  =>  Text file encoing   Other UTF-8 설정

Java  =>  Code Style  =>  Formatter  =>  New 클릭 my 입력후 OK 클릭
                                         Tab policy에서  Spaces only 설정


Web  =>   CSs Files/Htm Files/JSP Files  =>  UTF-8 설정



폰트 d2coding 사용 
  https://github.com/naver/d2codingfont/releases
  "C:\Windows\Fonts\" 경로에 복사

  크롬 기본 글꼴 : 맞춤
  익스플로어 기본 글꼴 : 웹 페이지 글꼴(Gulim), 일반 텍스트 글꼴(GulimChe)



@ View 초기화
  Window => Perspective  => Open Perspective  => Other  => Java EE

@ Eclipse에서 Project Explorer / Navigator  /  Outline / Task List
  Window  =>  Show View  =>  Other  에서 맨위에서 검색






@ Project Import Gradle 사용


1) gradle 명령어 모음

build.gradle             https://docs.gradle.org/4.2.1/userguide/eclipse_plugin.html

apply plugin: 'eclipse'


java-basic> gradle init --type java-application


java-basic> gradlew tasks --all


java-basic> gradlew EclipseProject


java-basic> gradlew cleanEclipseProject


java-basic> gradlew EclipseClasspath


java-basic> gradlew cleanEclipseProject


java-basic> gradlew Eclipse


java-basic> gradlew cleanEclipse




2) build.gradle 수정해서 jdk9으로 설정


apply plugin: 'eclipse'


eclipse {
  jdt {
    //if you want to alter the java versions (by default they are configured with gradle java plugin settings):
    sourceCompatibility = 9
    targetCompatibility = 9
    javaRuntimeName = "JavaSE-9"

    file {
      whenMerged { jdt
      }

      withProperties { properties ->
        properties["org.eclipse.jdt.core.compiler.codegen.targetPlatform"] = "9"
        properties["org.eclipse.jdt.core.compiler.source"] = "9"
        properties["org.eclipse.jdt.core.compiler.compliance"] = "9"
      }
    }
  }
}





eclipse {
  jdt {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    javaRuntimeName = "JavaSE-1.8"
    
    /*
    file {
      whenMerged { jdt
      }

      // .settings/org.eclipse.jdt.core.prefs 파일에 들어갈 값 설정
      withProperties { properties ->
        properties["org.eclipse.jdt.core.compiler.codegen.targetPlatform"] = "9"
        properties["org.eclipse.jdt.core.compiler.source"] = "9"
        properties["org.eclipse.jdt.core.compiler.compliance"] = "9"
      }
    }
    */
  }
}







3) gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

java-basic> gradlew cleanEclipse

java-basic> gradlew Eclipse


- C:\Users\bit-user\git\bitcamp\java-basic 폴더에서 .classpath 파일에서 JavaSE-9 설정 확인
  	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/
         org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-9/"/>

- C:\Users\bit-user\git\bitcamp\java-basic\.settings 폴더에서 org.eclipse.jdt.core.prefs 확인
  org.eclipse.jdt.core.compiler.codegen.targetPlatform=9
  org.eclipse.jdt.core.compiler.source=9
  org.eclipse.jdt.core.compiler.compliance=9


4) eclipse 에 Import

File => Import => General => Existing Projects into WorkSpace => Browse(폴더선택)
        - Select root directory : 압축 해제된 프로젝트 폴더
        - Select archive file   : 압축 상태인 프로젝트 압축파일



5) Import 에러

  오류: 기본 클래스 bitcamp.java100.Test16_1을(를) 찾거나 로드할 수 없습니다.
  원인: java.lang.ClassNotFoundException: bitcamp.java100.Test16_1

  Project > Context Menu => Proerties => Java Build Path 에서 jar 경로확인
  git에서 다운 받았기 때문에 Users 가 bit-user로 되어 있음
  노트북은 Users 가 user로 되어 있음

  gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse

  한 후 다시 Import 한다.


6) Import 의 Project 명이 폴더명과 다른경우(다른 폴더 복사했을 경우)

  - settings.gradle 파일에서 rootProject.name 변경

    rootProject.name = 'bitcamp-java-basic' => rootProject.name = 'java-basic'

  - .project 파일에서 <projectDescription> 변경
 
    <name>bitcamp-java-basic</name>  =>  <name>java-basic</name>


7) Synchronize gradle projects with workspace failed due to an error configuring eclipse

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse


8) Project 오른쪽 마우스(context menu)  >  Properties > Java Compiler => Version 확인
   
   





@@ Eclipse에서 Git 사용


@ Git Push 및 Pull

  Window  =>  Show View  =>  Other  =>  Git Repositories
  Window  =>  Show View  =>  Other  =>  Git Staging

  Git Repoitories 에서 해당 git에서 오른쪽 Context Menu  =>  Push to Stream

  Git Staging 에서 Unstaged Changes 에서 Staged Changes 로 파일 이동하고
  Commit Message에 메시지 입력

  Commit and Push 클릭해서 로그인

  한번 Commit 하면 이클립스 다시 실행





@ Eclipse에서 Git 자동로그인 해제

  Window  => Preference  =>  General  =>  Security  =>  Secure Storage  =>  Contents Tab에서 삭제
          => Default Secure Strorage => Git  =>  Delete



========================= 기타 설정 ==============================
     
 @ 단축키 등록

 -. Window > Preference > General > Keys > Command에서 File Search 이동 > 
    
    Binding 에 원하는 단축키 클릭 / In Windows > Apply

 
 @ 자동 완성 설정 해제

 -. 자동 완성 해제

    Windows > Preferences > Java > Editor > Content Assist > Enable auto activation : 


 -. 컨텐트 어시트 해제되어 있어도 Ctrl + Space하면 컨텐트 어시트 나타남

 
 @ 괄호 자동 완성 해제

 -. Windows > Preferences > Java > Editor > Typing > Automatically close


========================= 소스 네비게이션 =========================


 -. Ctrl + \  :  View Move (단축키 사용자 등록  Next View)
 -. Ctrl + [  :  New Package
 -. Ctrl + ]  :  New Class
 -. Ctrl + ;  :  단어 자동완성 (Alt + / , Word Completion, Editing Text)


 -. Shift + F12 : Open Attached Javadoc in a Browser(Shift + F2) 사용자 정의


 -. window > New Window  :  이클립스 새창

 -. Ctrl + M : 현재 활성화된 뷰나 에디터 최대화
 -. Ctrl + F6 : 소스간 이동
 -. Ctrl + F7 : 뷰간 이동 ( 에디터 최대창에서 Project Explorer 창 보인)
    Ctrl + \ (단축키 사용자 등록  Next View)

 -. Ctrl + F8 : 다음 Perspective로 이동(Debug, JavaEE)

 -. Ctrl + PageUp, Ctrl + PageDown : 소스탭 이동


 -. Ctrl + , : 현재 커서에서 이전 에러 난 곳으로의 커서 이동
 -. Ctrl + . : 현재 커서에서 이후 에러 난 곳으로의 커서 이동

  

 @ 단축키 등록 보기   [Ctrl + Shift + L]
이클립스 단축키 저장 파일
%workspace%\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.ui.workbench.prefs


========================= 소스 코드 편집 =========================


 -. 상위 주석 펼치기 : Window > Preference > Java > Folding > Header Comments


 -. F3(Ctrl + 마우스커서) : 선언된 변수로 이동, 메소드 정의부로 이동
 -. F4         : 클래스명을 선택하고 누르면 해당 클래스의 Hierarchy 를 볼 수 있다.

 -. Ctrl + O   : 해당 소스의 메소드 리스트를 확인하려 할때
 -. Ctrl + Shift + Down : Java Editor에서 다음 member로 이동

 -. Ctrl + Space       :  컨텐트 어시스트

 -. Ctrl + Shift + M : 특정 클래스 Import
 -. Ctrl + Shift + O : 자동으로 Import

 -. Ctrl + Shift + F : 전체 코드 자동 정리 
 -. Ctrl + I : 선택 블록 코드 자동 정리


 -. Ctrl + Shift + W : 에디터창 모두 닫기 
 -. Alt + Q  : 에디터창 모두 닫기(단축키 개인 등록, In Windows)
 -. Alt + Z  : 현재 에디터창 제외 모두 닫기(단축키 개인 등록, In Windows)

 -. Ctrl + /           :  주석 토글
 -. Ctrl + Shift + /   :  블록 주석 추가
 -. Ctrl + Shift + \   :  블록 주석 삭제



 -. Alt + Left / Right Arrow  : 이전 소스 위치로 커서 이동
 -. Alt + Up / Down Arrow   : 선택한 소스 위치 변경


 -. Ctrl + Left / Right Arrow  : 문자열 이동
 -. Ctrl + Shift + Left / Right Arrow  : 문자열 선택
 -. Shift + Alt + Left / Right Arrow : 블록 선택 (Up/ Down은 다른 기능)


 -. Shift + Alt + a : 블록 복사 => 마우스가 십자가로 바뀜


 -. Ctrl + F : 현재 파일에서 특정 문자를 찾거나 찾은 문자를 교체하는 방법

 -. Ctrl + Shift + R : 프로젝트에 포함된 리소스(여기서는 파일)중에 찾는 방법

 -. Ctrl + Shift + G : 현재 패키지에 함수를 호출하는 위치를 모두 찾아준다.



 -. 폴딩 설정 : Window > Preference > Java > Editor > Folding
 -. Ctrl + Numpad(-) : 해당소스 폴딩 닫기
 -. Ctrl + Numpad(+) : 해당소스 폴딩 열기

 -. Ctrl + Numpad(/) : 전체 폴딩 닫기
 -. Ctrl + Numpad(*) : 전체 폴딩 열기


 -. Alt + /          : 단어 자동완성
 -. Ctrl + Shift + x : 대문자로
 -. Ctrl + Shift + y : 소문자로



 -. Ctrl + H 단축키를 Open Search Dialog을 File Search로 변경 : 단축키 변경관 같음
    
    Open Search Dialog 기본 정보 : Binding(Ctrl + H), When(In Windows)
    


========================= 실행 및 디버깅 =========================

 -. Ctrl + Shift + B : 현 커서의 위치에 브레이크 포인터 설정/해제

 -. F11 : 디버깅 시작

 -. F8 : 디버깅 계속

 -. F6 : 한 줄씩 실행(Step Over)

 -. F5 : 한 줄씩 실행하되 함수일 경우 그 함수 내부로 들어감(Step Into)

 -. Ctrl + R : 디버거 중 현재 라인까지 실행(Run to Line)

 -. Ctrl + F11 : Run 파일 실행
 
 -. Ctrl + R : 현재 라인까지 실행(Run to Line)

 -. F12 : 에디터 활성화

 -. F12 : 컴파일 중 에러등으로 포커스가 다른데로 갔을 때 Editor 로 커서 이동


========================= 코드 템플릿 사용하기 =========================

1. Class에 주석 넣기

   Window > Preferences > Java > Code Style > 
            Code Templates > Comments > Types > Edit 버튼 클릭

   내용 수정
   
/**
 * <pre>
 * ${package_name}
 * ${file_name}
 * </pre>
 *
 * @Author  : ${user}
 * @Date    : ${date}
 * @Version : 
 * ${tags}
 */ 

Refactoring 단축키
Alt + Shift + T : Refactor Quick Menu - 리펙토링 메뉴 바로가기
Alt + Shift + R: 이름 변경(Rename)
Alt + Shift + V : 이동(Move)
Alt + Shift + C : Change Method Signature
Alt + Shift + M : Extract Method
Alt + Shift + L : Extract Local Variable
Alt + Shift + I : Inline

출처: http://fuzzy.tistory.com/171 [퍼지기능의 막가는 블로그]


========================= Refactoring =========================
    

 @ Setters and Getters 자동 추가

    Context Menu > Source > Generate Setters and Getters


 @ Super Class 만들기

   Context Menu > Refactor > Extract SuperClass  => Generalization

 
 @ 기본 Overiding 만들기

   클래스 파일에서 Ctrl + Space 한 후 오버라이딩할 메서드 선택


 @ toString(), hashCode(), equals() 오버라이딩 만들기

   Context Menu > Source > Generate toString()

   Context Menu > Source > Generate hashCode() and equals()

   


================================================================


Java SE : 
Java ME : Embedded Java
Java EE


Public Key        Private Key

http://tomcat.apache.org/


@ Codebook
마크다운 : //  =>  //:   

@ 가변 메소드
    static void sum(int... values) {
        int s = 0;
        for (int v : values) {
            s += v;
        }
        System.out.printf("합계: %d\n", s);
    }



        i = 4885223;
        int count = 0;
        int[] cnt = new int[10];
        while(i > 0) {
            cnt[i % 10]++;
            i /= 10;
        }
        
        int x = 0;
        while (x < cnt.length) {
            System.out.printf("%d = %d\n", x, cnt[x]);
            x++;
        }



=================================================================================


@ Java Window 프로그램


        AWT

         |

  Swing  + alpha  =>  SWT

         |

       JavaFX



=============================================================================


 -. 클래스 테스트 할 경우 main 함수를 만들어서 테스트한다.

 -. 테스트 한 후 main 삭제하고 run 하면 현재 클래스로 실행된다.

 -. main 이 있는 소스로 이동해서 run을 해야한다.


=============================================================================


@ 클래스 로딩되는 시점

// 1) 클래스 변수를 사용할 때 
//MyClass2.v1 = 200;

// 2) 클래스 메서드를 사용할 때 
//MyClass2.m1();

// 3) new 연산자를 사용할 때
//new MyClass2(); 
        
// 주의!
// => 레퍼런스 변수를 선언할 때는 클래스가 로딩되지 않는다.
// MyClass2 obj1 = null;


public class MyClass2 {
    // static member
    
    // 스태틱 변수 = 클래스 변수
    // => 클래스 이름으로 사용하고, 클래스에 소속된 변수라고 해서
    //    "클래스 변수"라 부른다.
    static int v1 = 100; // 스태틱 변수 = 클래스 변수
    static void m1() { // 스태틱 메서드 = 클래스 메서드
        System.out.println("MyClass2.m1()");
    }
    
    
    // instance member
    int v2 = 200; // 인스턴스 변수
    void m2() { // 인스턴스 메서드
        System.out.println("인스턴스.m2()");
    }
    
}

===================== 메모리 생성 및 해제 =============================


 클래스 static 변수는 Method Area에 생성된다.


 스태틱 변수는 JVM 종료할 때 메모리에서 해제
 스태틱 변수는 JVM 종료할 때 메모리에서 해제하기 때문에 메모리를 많이 차지


 new로 선언된 변수는 인스턴스변수는 무조건 Heap에 만들어진다.
 Heap에 있는 변수는 가비지 컬렉터가 메모리를 해제한다.


 그외는 Local 변수, 로컬에 선언된 레퍼런스 변수는 Stack에 만들어진다.


 인스턴스는 배열을 만들지 못하고 레퍼런스 배열을 만든다.

 클래스 배열을 정의(StatClass[] statclass3 = new StatClass[3];) 하면 statck 메모리에 생성

 메서드만 사용할 경우 인스턴스 변수( statclass3[0] = new StatClass(); )를 선언하지 않아도 된다.

 statclass3[0] = new StatClass(); 정의하면 instance 메모리에 배열의 값이 저장될 인스턴스 메모리가 생성된다.



 static 변수는 this을 붙여도 되나 굳이 붙일 필요가 없다.



=======================================================================


// 스태틱 변수 스태틱 메서드 : 인스턴스 변수 인스턴스 메서드
package bitcamp.java100.ch06.ex6;

import bitcamp.java100.ch06.ex5.Score2;

public class Test9 {
    
    // main(static method) 함수에서 instance variable 사용 불가
    // static class 에서 instance variable 사용 가능
    int ginstvar;
    
    // main(static method) 함수에서 static variable 사용 가능
    // static class 에서 static variable 사용 가능
    static int gstatvar;
    
    // main(static method) 함수에서 instance method 호출 불가
    void ginstMethod() {
        // instance variable 사용 가능
        ginstvar += 100;
        
        // static variable 사용 가능
        gstatvar += 100;
        
        System.out.println("ginstMethod() ginstvar = " + ginstvar);
        System.out.println("ginstMethod() gstatvar = " + gstatvar);
        
        // instance method에서 static method 호출 가능
        gstatMethod();
        

        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classnaem.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    // main 함수에서 static method에서 호출 가능
    // static class에서 호출가능
    static void gstatMethod() {
        // static method에서 instance variable 사용 불가
        //ginstvar = 100;  // 컴파일 오류
        
        // static method에서 static variable 사용 가능
        gstatvar += 100;
        
        //System.out.println("ginstMethod() ginstvar = " + ginstvar);  // 컴파일 오류!
        System.out.println("gstatMethod() gstatvar = " + gstatvar);
        
        // static method에서 instance method 호출 불가
        //ginstMethod();  // 컴파일 오류!
        
        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    
    // ***********************************************************
    // non-public, non-static class 선언가능하나 사용할 수 없음
    //class NonStatClass {     // 사용할 수 없음
    //}
    // ***********************************************************
    
    
    static class StatClass {
        // instance variable 초기값은 '0'
        int instvar;

        // static variable 초기값은 '0'
        static int statvar;
        
        // instance method(non-static method)는 this를 내장하고 있다.
        void instMethod() {
            this.instvar += 100;
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            this.statvar += 100;
            
            // instance method 에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            //instMethod();
            // instance method 에서 static method 호출 가능
            statMethod();
            
            System.out.println("instMethod() instvar = " + this.instvar);
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            System.out.println("instMethod() statvar = " + this.statvar); 
        }
        
        // static method(class method) 에서 this 사용할 수 없다.
        static void statMethod() {
            // static method에서 instance 내장변수 this 사용 불가
            //this.instvar += 100;  // 컴파일 오류!
            //this.statvar += 100;  // 컴파일 오류!
            
            // static class에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            
            // static method에서 instance method 호출 불가
            //instMethod();  // 컴파일 오류!
            
            // static method에서 instance variable 사용 불가
            //instvar += 100;  // 컴파일 오류!
            
            // static method에서 static variable 사용 가능
            statvar += 100;
            
            // static method에서 instance variable 사용 불가
            //System.out.println("m2() instvar = " + instvar);  // 컴파일 오류
            System.out.println("m2() statvar = " + statvar);
        }
    }
    
    public static void main(String[] args) {
        //A a = null;
        
        // main(static method) 에서 instance variable / method 사용 불가
        //ginstvar += 100;   // 컴파일 오류!
        //ginstMethod();      // 컴파일 오류!
        
        // main(static method) 에서 static variable / method 사용 가능
        gstatvar += 100;
        gstatMethod();

        System.out.println("gstatvar = " + gstatvar);
        
        
        //######################################################################################
        // instance reference 변수 선언과 동시에 클래스(변수, 메서드)가 Method Area에 로딩된다.
        // Heap에 인스턴스 변수만 메모리 생성되고 인스턴스 메서드는 생성되지 않음.
        // (클래스 메서드 즉 Method Area에 있는 함수를 호출)
        //######################################################################################

        // 인스턴스은 클래스 메서드(Method Area)를 호출한다.   
        // static 붙은 메서드는 클래스명.메서드명()
        // static 없는 메서드는 인스턴스명.메서드명()
        
        // new를 사용해서 instance variable 를 계속 선언하면 힙에 계속해서 인스턴스 메모리가 생성
        StatClass statclass1 = new StatClass();
        StatClass statclass2 = new StatClass();
        

        // instance.instance 사용 가능
        statclass1.instvar += 100;
        statclass1.instMethod();
        
        System.out.println("statclass1.instvar = " + statclass1.instvar);

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass2.statvar += 100;
        statclass2.statMethod();
        
        System.out.println("statclass2.statvar = " + statclass2.statvar);
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!

        // classname.static 사용 가능
        StatClass.statvar += 100;
        StatClass.statMethod();
        
        System.out.println("StatClass.statvar = " + StatClass.statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        // 배열을 인스턴스로 정의해야 한다.
        StatClass[] statclass3 = new StatClass[3];  // 객체 주소를 저장할 Stack 메모리 생성
        statclass3[0] = new StatClass();            // 데이터를 저장할 Heap 메모리 생성 
        statclass3[1] = new StatClass();
        statclass3[2] = new StatClass();
        
        // classarray.instance 사용 가능
        statclass3[0].instvar = 100;
        statclass3[0].instMethod();
        
        System.out.println("statclasss[0].instvar = " + statclass3[0].instvar);

        // classarray.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass3[0].statvar = 100;
        statclass3[0].statMethod();
        
        System.out.println("statclass3[0].statvar = " + statclass3[0].statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        StatClass[] statclass4 = new StatClass[3];

        // statclass1의 주소를 statclass4[0] 에 저장
	// statclass4[0] = new StatClass(); 가 필요 없다.
        statclass4[0] = statclass1;  
        
        System.out.println("statclass4[0].instvar = " + statclass4[0].instvar);
        System.out.println("statclass4[0].instvar = " + statclass4[0].statvar);
    }
}





================================== 클래스 생성자 =============================================
        

 @ 생성자 : 메모리를 만든후 최소한의 상태를 만드는것

   - 인스턴스를 사용 가능하도록 유효한 상태로 만드는 것

   - 즉 변수의 초기값 설정과 배열의 초기 상태을 만들기 위해서 사용


   - 생성자는 클래스명과 같다(생략 가능하며, 컴파일러가 자동 추가)
     classname () {}

   - 수퍼클래스의 생성자(생략 가능하며, 컴파일러가 자동 추가)
     super();
  

    //생성자 : 메모리를 만든후 최소한의 상태를 만드는것
    //즉 배열의 초기 상태을 만듬

    Score() {
     this.subjects = new int[3];
    }
    
    
    Score(String name, int kor, int eng, int math) {  // 가변 파라미터
     this.name = name;        // this.name(instance variable) 과 name(local variable, method parameter)
     //this.subjects[0] = kor;
     //this.subjects[1] = eng;
     //this.subjects[2] = math;
     
     this.subjects = new int[] {kor, eng, math}; // 초기값 할당과 구분
     
     this.compute();
    }



================================== 클래스 상속(Inheritance) ====================================


  class 클래스명 extends 기존클래스명 {...}

  상속을 해주는 클래스를 "수퍼(super)/부모(parent) 클래스"라고 부른다.

  상속을 받는 클래스를 "서버(sub)/자식(child) 클래스"라고 부른다.

  최상위 수퍼클래스는 Object 클래스이다.

  기존 클래스의 링크 정보를 등록하여 수퍼클래스의 멤버(필드, 메서드)를 상속 받는다.

  수퍼클래스의 멤버(변수, 메서드)를 상속받아 새로운 변수 및 기능을 추가한다.

  수퍼클래스 코드에 문제가 있으면 그 코드를 수정하면 즉시 서브 클래스들은 수정된 코드를 사용하게 된다.

  
  @ 상속의 종류

    1) Specialization

       - 수퍼 클래스를 상속 받아 기능을 추가하여 더 특별한 서브 클래스를 만드는 것.

    2) Generalization

       - 서브 클래스들의 공통 변수나 공통 메서드를 추출하여 수퍼 클래스를 정의하는 것.

       - Context Menu > Refactor > Extract SuperClass  => Generalization



================================== 클래스 캡슐화(Encapsulation) ================================


 클래스 멤버(필드, 메서드)에 접근을 제어하는 기법

 - public    : 같은 패키지와 다른 패키지에 모두 공개
 - protected : 같은 패키지와 다른 패키지에 있는 자손 클래스에게 공개
 - (default) : 같은 패키지에 소속된 클래스에게만 공개
 - private   : 비공개

   public > protected > default > private


 - 패키지 멤버 클래스는 public, default 만 가능하며, 
   패키지에 선언되었기 때문에 같은 패키지만 공개하면 된다.


 - 클래스 안에 선언된 클래스를 "중첩(nested) 클래스"라 부른다.

 - 캡슐화의 존재 이유 : 인스턴스 변수에 무효한 값이 저장되는 것을 방지함으로써 추상화가 무너지는 것을 막는다.

 - 추상화(Abstraction) : 사물이나 사람, 업무 등을 데이터와 메서드로 표현하는 것

 - 필드(주로 값의 입력)를 접근 제한하면 필드의 값을 설정하는 메서드(Setter, Getter)는 전체 공개를 해야하고, 
   외부에서 필요없는 메서드(계산처리)는 접근 제한한다.
  


=============================== 다형적 변수 (Polymorphism) ========================================

 수퍼 클래스의 레퍼런스는 서브 클래스의 인스턴스를 주소를 저장할 수 있다.

 서브 클래스의 인스턴스는 무조건 수퍼 클래스의 인스턴스를 모두 갖고 있기 때문이다.

 이렇게 상속 관계에 따라 한 레퍼런스에 다양한 클래스의 객체 주소를 저장할 수 있다고 해서 "다형적 변수" 라고 부른다.

 구체적인 타입을 지정하기 보다는 그것의 상위 타입을 지정함으로써 
 그 자리에 다양한 타입의 객체를 넣을 수 있다.
 
 public class Car extends Vehicle {}
 public class Truck extends Car {}
 c = new Car();
 c = new Truck();  // Car의 멤버를 사용할 수 있다.

 Sedan c2 = (Sedan)c;  // 명시적 형변환을 해주면 Car의 멤버를 사용할 수 있다.



======================= 오버라이딩 Overrigind(Polymorphism) =====================================


@ 오버라이딩의 메서드 호출

  수퍼클래스의 메서드를 상속받아 메서드 기능을 재정의

  @Override을 메서드명 앞에 붙여 에러를 방지한다.


  오버라이딩 규칙 
    => 접근 범위 : 같거나 확장 (private < default < protected < public)
    => 접근 범위 축소하면 컴파일 오류

    => 리턴 타입 : 반드시 일치
    => 메서드명  : 반드시 일치
    => 파라미터 타입 및 개수 및 순서 : 반드시 일치
    => 파라미터명 : 상관없음

    => 메서드명은 같지만 파라미터의 타입이 다르거나 갯수, 순서가 다른 경우 새 메서드를 추가한것
  

  현재 클래스에 메서드가 정의되었는지 확인하고, 없으면 수퍼 클래스에서 정이 되었는지 확인
  this.compute();   


  현재 클래스가 아니라 수퍼클래스에서 정의되었는지 확인
  super.compute();



  오버라이딩 된 메서드는 호출되는 것은 클래스의 인스턴스 주소에 따라서 결정


  HashSet은 ArrayList 나 MashMap, HashTable 처럼 객체의 주소를 보관

  HashSet는 개체의 주소를 중복해서 보관하지 않는다.


  Object에서 상속받은 toString(), hashCode(), equals() 함수를 오버라이딩 해서 사용
  
  toString() : 인스턴스 변수의 값을 확인

  hashCode(), equals() : 인스턴스의 변수의 값이 같은지 확인


  StringBuffer는 equals()를 재정의하지 않았기 때문에 Object의 equals()를 그대로 사용한다.

  hash값 : 각 인스턴스를 구분할 때 사용할 디지털 지문!



========================= 오버로딩 Overloading(Polymorphism) =================================


  파라미터의 갯수, 타입, 순서가 다르더라도 같은 기능을 수행하는 메서드에 
  같은 이름을 부여하여 사용할 수 있게하는 문법

  메서드 호출 구분은 갯수, 타입, 순서로 구분한다. 

  리턴 값을 받느냐 안 받느냐로 호출할 메서드를 구분할 수 없다.

  리턴 타입만 다른 메서드는 추가할 수 없고, 파라미터의 갯수, 타입, 순서가 다르게 해야한다.

  파라미터 타입이 메서드와 다를 때는 암시적 타입 캐스팅으로 가능한 메서드를 호출한다.

  수퍼 클래스에서 상속 받은 메서드와 이름은 같지만 파라미터가 다른 메서드를 추가하면 오버로딩이다.




======================================= 제네릭(Generic) =====================================

  제테릭이 적용된 클래스를 사용하면 여러 개의 클래스를 만들 필요가 없이

  하나의 클래스로 여러 타입의 객체를 사용할 수 있다.


  제네릭을 사용하는 이유는 타입의 안정성을 제공하고, 타입체크와 형변환을 생략하여 코드가 간결하다.

  선언할 수 있는 타입은 객체 타입과, wrapper(primitive 변수의 객체) 클래스만 가능하다


  클래스가 어떤 데이터 타입을 사용할 것인지 타입명을 받는다
  
  Type의 약자인 T를 주로 사용

  E - Element (used extensively by the Java Collections Framework)
  K - Key
  N - Number
  T - Type
  V - Value
  S,U,V etc. - 2nd, 3rd, 4th types


  Stack<Contact> contacts = new Stack<>();
  contacts.push(new Contact("홍길동", "hong@test.com", "1111-1111"));  // Contact 생성자

  public class Stack<T> {
    
    // 그리고 사용자가 전달한 타입의 이름을 코드 곳곳에 지정하면 된다.
    private class Box {
        T value;
        Box next;
        
        public Box() {}
        
        public Box(T value) {
            this.value = value;
        }
    }
    
    public void push(T value) {
        // 새 상자를 만들어 값을 저장한다.
        Box box = new Box(value);
    }
  }

  Iterator<제네릭 타입> interator = list.iterator();

  ex) List 계열, Set 계열
      ArrayList<Score> list = new ArrayList<>();
      Iterator<Score> iterator = list.iterator();

     
  ex) Map 계열
      HashMap<String, Contact> map = new HashMap<>();
      Iterator<Contact> iterator = map.values().iterator();

      while(iterator.hasNext()) {
          System.out.println(iterator.next());
          iterator.remove();
      }


=========================== @SuppressWarnings Annotation ========================================

  

    @SuppressWarnings("unchecked")
    T get(int index) {
        if (index < 0 || index >= this.cursor) {
            return null;
        }
        return (T)this.list[index];
    }

    return (T)this.list[index]; => 
      => 제네릭 하면서 타입 캐스팅에 확신이 없을 때 
         커서를 소스위에 올리고(단축키 F2)  add @SuppressWarnings("unchecked") 추가


    1. all : 모든 경고를 억제
    2. cast : 캐스트 연산자 관련 경고 억제
    3. dep-ann : 사용하지 말아야 할 주석 관련 경고 억제
    4. deprecation : 사용하지 말아야 할 메소드 관련 경고 억제
    5. fallthrough : switch문에서의 break 누락 관련 경고 억제
    6. finally : 반환하지 않는 finally 블럭 관련 경고 억제
    7. null : null 분석 관련 경고 억제
    8. rawtypes : 제네릭을 사용하는 클래스 매개 변수가 불특정일 때의 경고 억제
    9. unchecked : 검증되지 않은 연산자 관련 경고 억제
    10. unused : 사용하지 않는 코드 관련 경고 억제




============================== @Deprecated Annotation ====================================

    
 -. @Deprecated : 기존에 만든 메서드는 현재 여러곳에 사용중이기 때문에 그대로 두고

    메서드 사용하지 않도록 경고하고 기능이 같은 메서드를 구현해서 사용하도록한다.

    @Deprecated
    public void move() {
        // move의 기능을 run()으로 옮기고, 여기서는 run()을 호출한다.
        this.run();
        
        // 즉 move() 메서드는 예전에 만든 프로젝트를 위해 run()의 껍데기 역할을 한다.
    }
    
    // 신규 프로젝트에서는 run()을 사용해야 하기 때문에 
    // 수퍼클래스에서 상속 받은경우 run()을 오버라이딩한다.
    @Override
    public void run() {
        System.out.println("간다.");
    }


======================================= 컬렉션 프레임워크 =====================================

  컬렉션즈 프래임워크라는 것은 다른 말로는 컨테이너라고도 부른다. 
  즉 값을 담는 그릇이라는 의미이다. 그런데 그 값의 성격에 따라서 컨테이너의 성격이 조금씩 달라진다. 
  자바에서는 다양한 상황에서 사용할 수 있는 다양한 컨테이너를 제공하는데 
  이것을 컬렉션즈 프래임워크라고 부른다.

  
  List : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
         ArrayList, LinkedList, Stack, Queue


  Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
        HashSet, TreeSet


  Map : 키와 값의 쌍으로 이루어진 데이터의 집합. 
        순서는 유지되지 않으며, 키는중복을 허용하지 않고, 값을 중복을 허용한다. 
        HashMap, Hashtable, TreeMap,
   
  toArray
        값을 배열로 꺼내고 싶다면, 값을 모두 담을 수 있는 배열을 만든 다음에,
        toArray()의 파라미터로 배열 주소를 넘겨라!
        그러면 배열에 객체들의 주소를 담아줄 것이다.
        만약 파라미터로 제공된 배열을 크기가 HashSet에 보관된 객체들의 수 보다 작다면,
        따로 배열을 새로 만든 다음에 그 배열의 주소를 리턴할 것이다.
	
        HashSet<String> set = new HashSet<>();

        String[] arr1 = new String[set.size()];
        String[] arr2 = set.toArray(arr1);

        String[] arr = set.toArray(new String[set.size()]);


        // ArrayList
        Iterator<String> iterator = list.iterator();
        

        // HashSet
        Iterator<String> iterator = set.iterator();


        // HashMap
        Iterator<Contact> iterator = map.values().iterator();

    
        // 값 출력
        while(iterator.hasNext()) {
            System.out.println(iterator.next());
        }



     arr[cursor++] = 80;   // Auto_Boxing => new Integer(80)




========================== 이터레이터(Iterator) 인터페이스 객체 ==========================

- 모든 컬렉션(Collection)으로 부터 정보를 얻을 수 있는 인터페이스 입니다.

  public interface Iterator {
    boolean hasNext();
    Object next();
    void remove();
  }



 ArrayList<String> list = new ArrayList<>();
 Iterator<String> iterator = list.iterator();

 - iterator() 메서드의 의미?
   => iterator()는 Iterator 인터페이스를 구현한 어떤 클래스의 인스턴스를 만들어 리턴한다.
   => iterator()는 Iterator 인터페이스를 구현한 어떤 클래스의 객체를 리턴한다.
   => iterator()는 Iterator 인퍼페이스를 구현한 객체를 리턴한다.
   => iterator()는 Iterator 구현체를 리턴한다.
   => iterator()는 Iterator 객체를 리턴한다.



======================================= 추상클래스 ======================================

-. 서브 클래스가 사용할 필드와 메서드를 물려주는 역할을 한다.

-. 추상 클래스로 선언하면 직접 인스턴스를 생성할 수 없다.(//Car car = new Car(); // 컴파일 오류!)


    # 추상클래스와 추상메서드
    
    public abstract class Car {
        
        // 추상클래스에는 기본적인 필드와 메서드를 선언
        String model;
        int cc;
        
        public void stop() {
            System.out.println("멈춘다.");
        }
        
        // Car의 모든 서브 클래스는 반드시 추상메서드를 구현해야한다.
        // 추상클래스(수퍼클래스)에서는 구현하면 안된다.
        public abstract void run();
    }
    
    
    public class Sedan extends Car {
        
        boolean isOpen;
        
        // 오버라이딩 하는 메서드는 가능한 애노테이션을 붙인다.
        // 자동 생성 : Sedan에 커서 이동하여 F2키를 누르고 'add unimplemented methods' 클릭
        @Override
        public void run() {
            if (isOpen) {
                System.out.println("시원하게 달린다.");
            }
        }
        
        public void openSunroof() {
            System.out.println("썬루프 연다.");
        }
        
        public void closeSunroof() {
            System.out.println("썬루프 닫는다.");
        }
    }



    # 추상메서드와 인스턴스 메서드 사용
    
    public abstract class A {
        int v1;
        
        public void m1() {
            System.out.println("A.m1()");
        }
    }
    
    public class B extends A {
        int v2;
        
        public void m2() {
            System.out.println("B.m2()");
        }
    }
    
    
    public class Test {
        public static void main(String[] args) {
            // 추상 클래스의 서브 클래스를 사용한다.
            B obj = new B();
            obj.m1();
            obj.m2();
            
            System.out.println("----------------------------");
            
            // 물론 레퍼런스를 만들 때는 추상 클래스도 사용할 수 있다.
            A obj2 = new B();
            
            // 다만 obj2로 사용할 수 있는 메서드는
            // obj2 타입에 제한된다.
            obj2.m1();
            //obj2.m2(); // 컴파일 오류!
            
            // obj2에는 실제 B 객체(의 주소)가 저장되어 있다.
            // B의 원래 기능을 쓰고 싶다면, 형변환하라!
            ((B)obj2).m2();
            
            B obj3 = (B)obj2;
            obj3.m2();
        }
    }




======================================= 인터페이스 ======================================


 -. 인터페이스는 사용자(caller)와 사용되는자(callee) 사이의 호출 규칙을 정의할 때 사용하는 문법이다.


    public interface Protocol{
	// 필드는 상수만 가능
        public static final float PI = 3.14159f;
        
        // => public 을 생략할 수 있다.
        static final int AA = 100;
        
        // => static 을 생략할 수 있다.
        final int BB = 200;
        
        // => final을 생략할 수 있다.
        int CC = 300;


        // 호출 규칙이라함은 메서드를 의미한다.
        // 추상메서드이고, abstract가 생략해도 컴파일러가 자동 생성    
        /*public abstract*/ void m1();
        void m2();
    }

    public class Callee implements Protocol {
	// 인터페이스에 선언된 모든 추상 메서드를 반드시 구현
    	// 자동 생성 : Callee 에 커서 이동하여 F2키를 누르고 'add unimplemented methods' 클릭
        @Override
        public void m1() {
            System.out.println("m1()...");
        }

        @Override
        public void m2() {
            System.out.println("m2()...");

            // 인터페이스의 상수 값을 직접 사용할 수 있다.
            System.out.println(Protocol3.AA);
        }
    }



 -. 인터페이스를 구현한 클래스를 상속 받은 모든 자손 클래스들은 그 인터페이스를 구현한 것이 된다.

    public class Test extends Callee  {
        void m3() {
            System.out.println("m3()");
        }
    }



 -. 클래스는 다중 상속은 불가능하지만 다중 구현은 가능하다.


    public class Test3 implements A, C {
        
        // A의 m1()과 C의 m1()을 동시에 만족시킨다.
        @Override public void m1() {System.out.println("m1()");}
        
        // C의 m3()를 구현한 것이다. 
        @Override public void m3() {System.out.println("m3()");}
        
    }


 -. 인터페이스에서 다중 상속이 불가능한 경우

   public interface Test4 extends A, E {


 -. 인터페이스에서 다중 구현이 불가능한 경우





 -. default 문법 (JDK 8에서 추가)

    // 객체 사용하기 전에 준비 시키는 메서드
    default void init() {};
    
    // 프로그램을 종료하기 전에 객체에게 마무리 작업을 시키는 메서드
    default void destroy() {};
    
    // default : 인터페이스에 새 규칙이 추가될 경우 기존 소스는 에러가 발생하므로,
		 새규칙을 추가하려면 수정 작업이 많아지므로,
                 규칙을 따르지 않게 하기 위해서 default 문법을 도입





======================================= 예외 처리 ======================================


    Object - Throwable - Error - LinkageError, ThreadDeath, VirtualMachineError

                       - Exception - RuntimeException - ArithmeticException, 
                                   |                  - NullPointerException
                                   |                  - IndexOutOfBoundException
                                   |                  - SecurityException
                                   |
                                    - IOException     - EOFException
                                                      - FileNotFoundexception
                                                      - InterrupedIOException
                                                      - CloseNotFoundException



 예외의 종류: 
 1) try...catch... 사용을 강제하지 않는 예외
    => Error와 RuntimeException(Exception의 서브 클래스) 계열의 예외
    => try...catch...로 예외를 처리하지 않더라도 컴파일 오류는 아니다!
 
 2) try...catch... 사용을 강제하는 예외
    => Exception 계열의 예외 
    => 즉 try...catch로 예외를 처리하지 않으면 컴파일 오류 발생!


 3) try...catch...finally
    -. finally 블록은 try 블록을 나가기 전에 반드시 실행한다.
    -. catch 블록 없이 사용할 수 있다.
    -. 사용한 자원을 자동으로 해제시킬때 사용

    PrintWriter out = null;
    try {
        out = new PrintWriter(new FileWriter("OutFile.txt"));
        ...
    } catch (IOException e) {
        ...
    } finally {
        if (out != null) 
            out.close();
    }


 4) try-with-resources (JDK 7 추가문법)

        try (
            // java.lang.AutoCloseable 규칙에 따라 만든 클래스의 객체여야 한다.
            // AutoCloseable 인터페이스를 구현한 클래스는 사용할 수 있다.
            // ( class MyClass implements AutoCloseable {   =>  블록에 close() 메서드 오버라이딩 )
            // FileWriter AutoCloseable 구현체( AutoCloseable 규칙에 따라 close() 메서드가 있다)
             MyClass obj = new MyClass()
        ) {
            System.out.println("try 블록 실행");
            
            switch (str) {
            case "a": throw new Exception();
            case "b": throw new IOException();
            case "c": throw new FileNotFoundException();
            case "d": throw new SQLException();
            }
            
            System.out.println(str);  
        } catch (IOException|SQLException e) {
            // 파라미터를 선언할 때 자식 클래스부터 나열
            // 형제 관계의 예외 클래스는 이렇게 OR 연산자를 사용하여
            // 파라미터 타입을 나열할 수 있다.
            System.out.println("IOException|SQLException 예외 처리");
            
        } catch (Exception e) {
            // 예외 클래스 중에서 수퍼 클래는 이렇게 별도로 선언한다.
            System.out.println("Exception 예외 처리");
        }



 5) 커스텀 예외 클래스를 이용하여 예외를 구분하기


    // 특별한 예외 클래스를 정의한다.
    public class EmptyStringException extends Exception {
        public EmptyStringException() {
            super(); // 그냥 수퍼 클래스의 기본 생성자를 호출한다.
        }
    
        public EmptyStringException(String message) {
            super(message); // 그냥 수퍼 클래스의 메시지를 받는 생성자를 호출한다.
        }
    
        // 그 밖에 필드나 메서드를 추가할 필요가 없다.
        // 이 클래스의 목적은 클래스 타입으로 예외를 구분하기 위함이다.
        // 단 간단한 메시지는 저장할 수 있도록 생성자를 정의하라!
    
    }


    static void input() throws Exception {
        Score score = new Score();
        
        System.out.print("이름? ");
        score.name = keyScan.nextLine();
        
        if (score.name.length() == 0) {
            // 예외 객체를 던진다.
            throw new EmptyStringException("이름이 빈 문자열입니다.");
        }
        
        System.out.print("국어? ");
        score.kor = Integer.parseInt(keyScan.nextLine());
        if (score.kor < 0 || score.kor > 100)
            // 예외 객체를 던진다.
            throw new ScoreOutOfBoundsException();
        
        list.add(score);
    }


    public static void main(String[] args) {
        while (true) {
            // input()에서 예외 클래스를 이용하여 예외 상황을 전달하기 때문에 
            // input()을 호출하는 쪽에서는 catch 블록으로 예외를 쉽게 구분할 수 있다.
            try {
                input();
                // 다음과 같이 예외가 발생할 때 클래스 타입으로 구분하기 때문에
                // 코드를 해석하기 쉽다. 즉 유지보수가 쉽다.
            } catch (EmptyStringException e) {
                System.out.println("입력 문자열이 비어 있습니다.");
                
            } catch (ScoreOutOfBoundsException e) {
                System.out.println("점수의 범위를 벗어났습니다.");
                
            } catch (NumberFormatException e) {
                System.out.println("숫자 형식이 아닙니다.");
                
            } catch (Exception e) {
                // 기타 예외는 어떤 상황인지 유추하기 힘들다.
                // 이런 경우 어디에서 예외가 발생했는지 상세하게 조사할 필요가 있다.
                // 이때 사용하는게 호출 단계를 출력해 보는 것이다.
                e.printStackTrace();
            }
        }
    }





======================================= 익명클래스 ======================================

  인터페이스 클래스 구현체 > 중첩 클래스 > 로컬 클래스 
                           > 익명 클래스(인터페이스, 수퍼클래스 생성자) > 익명클래를 함수안에 추가


 

  1) FileNameFilter을 MyFileNameFilter 클래스로 구현

        
    public class Test5_1 {
    
        public static void main(String[] args) {
            
            File file = new File(".");
    
            // 디렉토리에 들어 있는 파일이나 디렉토리 이름을 알아낼 때 
            // 특정 조건에 부합하는 이름만 꺼내고 싶을 때가 있다.
            // 그럴 때 list()의 파라미터로 필터 기능을 수행하는 객체를 
            // 전달하라! 이름을 꺼낼 때 그 필터를 사용하여
            // 리턴하는 배열에 포함할지 여부를 결정한다.
            //
            // ver 1: list()에서 사용할 필터 클래스는 패키지 멤버로 만든다.
            // => 오직 이 클래스에서만 사용하는 클래스인데
            //    굳이 패키지 멤버로 만들 필요가 있을까?
            String[] filenames = file.list(new MyFilenameFilter());
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }


    public class MyFilenameFilter implements FilenameFilter {
    
        @Override
        public boolean accept(File dir, String name) {
            File file = new File(dir, name);
            if (file.isDirectory())
                return true;
            else 
                return false;
        }
    }



  2) 중첩클래스

    
    public class Test5_2 {
    
        // 파일만 걸러내는 필터
        static class MyFilenameFilter implements FilenameFilter {
            @Override
            public boolean accept(File dir, String name) {
                File file = new File(dir, name);
                if (file.isDirectory())
                    return false;
                else 
                    return true;
            }
        }
        
        public static void main(String[] args) {
            
            File file = new File(".");

            // ver 2: list()에서 사용할 필터 클래스를 중첩 클래스로 만든다.
            // => 오직 이 클래스에서만 사용하는 클래스로 선언한다.
            String[] filenames = file.list(new MyFilenameFilter());
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }



  3) 로컬 클래스

    
    public class Test5_3 {
    
        public static void main(String[] args) {
            // 파일명이나 디렉토리명이 .으로 시작하는 경우는 
            // 결과에서 제외하자!
            class MyFilenameFilter implements FilenameFilter {
                @Override
                public boolean accept(File dir, String name) {
                    if (name.startsWith("."))
                        return false;
                    else 
                        return true;
                }
            }
            
            File file = new File(".");

            // ver 3: list()에서 사용할 필터 클래스를 로컬 클래스로 만든다.
            // => 오직 이 클래스의 main()에서만 사용하는 클래스로 선언한다.
            String[] filenames = file.list(new MyFilenameFilter());
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }





  4) 익명 클래스(인터페이스, 수퍼클래스 생성자)
    
    public class Test5_4 {
    
        public static void main(String[] args) {
            // .으로 시작하는 파일이나 디렉토리만 결과에 포함시킨다.
            FilenameFilter filter = new FilenameFilter() {
                @Override
                public boolean accept(File dir, String name) {
                    if (name.startsWith("."))
                        return true;
                    else 
                        return false;
                }
            };
            
            File file = new File(".");

            // ver 4: list()에서 사용할 필터 클래스를 익명 클래스로 만든다.
            // => 오직 한 개의 객체만 생성할 클래스라면 익명 클래스로 
            //    만들어도 된다.
            String[] filenames = file.list(filter);
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }




  5) 익명클래를 함수안에 추가(안드로이드에서 주로 사용)

    
    public class Test5_5 {
    
        public static void main(String[] args) {
            File file = new File(".");

            // ver 5: list()에서 사용할 필터 클래스를 익명 클래스로 만든다.
            // => 단 저 위에 멀리 익명 클래스의 코드를 두지 말고,
            //    그 익명 클래스를 사용하는 코드 가까이에 두어라.
            //
            String[] filenames = file.list(new FilenameFilter() {
                @Override
                public boolean accept(File dir, String name) {
                    if (name.startsWith("."))
                        return true;
                    else 
                        return false;
                }
            });
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }




======================================= 파일 구분 ======================================



     파일 쓰기: Byte 스트림 사용 => 바이너리 파일 쓰기
     바이너리 파일
     - 메모장과 같은 텍스트 편집기로 유효한 편집할 수 없는 파일 
     - 전용 편집기가 필요하다.
     - 예) .hwp, .doc, .xls, .ppt, .avi, .mp3, .exe, .class, .psd,
           .gif, .jpeg, .tiff 등
     
     텍스트 파일
     - 메모장과 같은 단순 텍스트 편집기로 편집할 수 있는 파일
     - 문자집합에 따라 인코딩된 바이트 데이터이다.
     - 예) .txt, .csv, .html, .css, .js, .c, .cpp, .rtf, .bat, .sh 등
     
     인코딩(encoding)
     - 어떤 규칙에 따라 특정 바이트 값으로 변환하는 것.
     - 예) 아날로그로 입력된 소리 ==> .wav 파일 생성
       예) 일반 데이터를 ==> 암호화데이터 
       예) .bmp ==> .jpeg
    
     디코딩(decoding)
     - 어떤 규칙에 따라 원래의 값으로 변환하는 것.
     - 예) .jpeg ==> .bmp
       예) 암호화된 데이터 ==> 원래 데이터
    




======================================= 파일 입출력 ======================================





 입출력을 다루는 클래스의 분류
 1) Data Sink Stream 클래스
 => 데이터를 저장소에 직접 저장하고 읽는 클래스이다.

 => 바이너리 스트림 클래스 예)  InputStream / OutputStream 의 서브 클래스들
    - 2 바이트 유니코드 값으로 변환

    - FileInputStream/FileOutputStream => 파일    바이트 단위로 데이터를 읽는다
    - ByteArrayInputStream/ByteArrayOutputStream => 메모리
    - PipedInputStream/PipedOutputStream => 다른 프로그램(프로세스)

 => 캐릭터 스트림 클래스 예)  Reader / Writer 종류
    - 변환과정 없이 바이트 값으로 출력(File Foramt으로 데이타 분석)

    - FileReader/FileWriter => 파일 
    - CharArrayReader/CharArrayWriter => 메모리 
    - StringReader/StringWriter => 메모리 
    - PipedReader/PipedWriter => 다른 프로그램(프로세스)
 

 2) Data Processing Stream 클래스 
 => 읽은 데이터 또는 출력할 데이터를 가공하는 클래스이다.

 => 바이너리 스트림 클래스 예)    InputStream / OutputStream 의 서브 클래스들
    - BufferedInputStream/BufferedOutputStream
    - DataInputStream/DataOutputStream
    - ObjectInputStream/ObjectOutputStream
    - PrintStream
 
 => 캐릭터 스트림 클래스 예)     Reader / Writer 종류
    - BufferedReader/BufferedWriter
    - LineNumberReader
    - FilterReader/FilterWriter
    - PrintWriter




 1) Data Sink Stream 클래스

        // 1) 바이트 단위로 데이터를 읽어주는 객체 준비
        FileInputStream in = new FileInputStream(
                                    new File("sample/a.jpg"));
        
        // 2) 바이트 단위로 데이터를 출력할 객체 준비
        FileOutputStream out = new FileOutputStream(
                                    new File("sample/a2.jpg"));
                
        
        // 3) 바이트를 읽어서 그대로 출력한다.
        int b; 
        while ((b = in.read()) != -1) {
            out.write(b);
        }
        
        // 4) 항상 사용을 마친 자원은 해제시킨다.
        in.close();
        out.close();
        



// 데코레이터(Decorator)


    // 상속을 이용하여 기능을 확장하는 대신에
    // 기존 객체를 포함하고 여기에 기능을 덧붙이는 형태! 
    public class MyBufferedInputStream2 {
        
        // 왜 InputStream 레퍼런스를 선언했는가?
        // => InputStream 레퍼런스는 FileInputStream 외에도 
        //    그 하위 클래스의 모든 객체를 가리킬 수 있기 때문이다.
        // => 즉 더 많은 종류의 객체를 포함하기 위해서 이 타입으로 선언했다.
        InputStream worker;
        
        byte[] buf = new byte[8192];
        int len; // 버퍼에 저장한 바이트 개수
        int cursor; // 버퍼에서 읽을 바이트 위치
        
        public MyBufferedInputStream2(InputStream worker) {
            this.worker = worker;
        }
        
        public int read() throws IOException {
            if (cursor >= len) { // 버퍼가 비었으면 다시 버퍼를 채운다.
                cursor = 0; // 커서는 다시 0으로 초기화시킨다.
                len = worker.read(buf);
                if (len == -1) // 파일에서 읽을 데이터가 없다면 
                    return -1;
            }
            
            return buf[cursor++] & 0x000000FF;
        }
    }




    public class Test2_5 {
        public static void main(String[] args) throws Exception {
            
            // 데이터 준비 
            // => 랜덤 메서드를 사용하여 임의의 값을 400만개를 준비한다.
            int[] data = new int[4000000];
            
            for (int i = 0; i < data.length; i++) {
                data[i] = (int)(Math.random() * 100000);
            }
            
            // 파일에 출력할 객체 생성
            FileOutputStream out = new FileOutputStream("./test3.dat");
            
            // 중간에서 버퍼 기능을 제공할 객체 생성
            // 실제 출력하는 일은 위에서 생성한 FileOutputStream이 할 것이다.
            MyBufferedOutputStream2 out2 = new MyBufferedOutputStream2(out);
            
            // 4백만개의 데이터를 출력해보고, 걸린 시간을 알아보자!
            
            long start = System.currentTimeMillis();
            
            for (int b : data) {
                out2.write(b);
            }
            
            // 버퍼에 남은 마지막 찌끄러기 출력하기
            out2.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            out.close();
            
        }
    }
 






// Data Processing Stream 캐릭터 스트림 클래스 사용법 

      

      BufferedInputStream 


      public class Test3_4 {
        public static void main(String[] args) throws Exception {
            
            // FileInputStream 객체를 별도 레퍼런스에 저장하지 않고
            // 바로 BufferedInputStream에 전달한다.
            BufferedInputStream in = new BufferedInputStream(
                    new FileInputStream(new File("sample/jls9.pdf")));
            
            // FileOutputStream 객체를 별도의 레퍼런스에 저장하지 않고
            // 바로 BufferedOutputStream에 전달한다.
            BufferedOutputStream out = new BufferedOutputStream(
                    new FileOutputStream(new File("sample/jls9-4.pdf")));
            
            
            // 데이터를 읽어서 출력한다.
            int b;
            long start = System.currentTimeMillis();
            
            while ((b = in.read()) != -1) {
                // 내부적으로 버퍼에 읽고, 버퍼의 내용을 출력한다.
                out.write(b);
            }
            
            // 버퍼에 남은 잔여 데이터를 출력해야 한다.
            out.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            // 항상 사용을 마친 자원은 해제시킨다.
            // BufferedInputStream을 close() 하면 
            // 이 클래스가 의존하는 FileInputStream도 함께 close() 된다.
            // BufferedOutputStream도 마찬가지이다.
            in.close();
            out.close();
            
            System.out.println("파일 복사 완료했음!");
        }
    }


    

    BufferedOutputStream 


    public class Test2_6 {
        public static void main(String[] args) throws Exception {
            
            // 데이터 준비 
            // => 랜덤 메서드를 사용하여 임의의 값을 400만개를 준비한다.
            int[] data = new int[4000000];
            
            for (int i = 0; i < data.length; i++) {
                data[i] = (int)(Math.random() * 100000);
            }
            
            // 파일에 출력할 객체 생성
            FileOutputStream out = new FileOutputStream("./test3.dat");
            
            // 중간에서 버퍼 기능을 제공할 객체 생성
            // 실제 출력하는 일은 위에서 생성한 FileOutputStream이 할 것이다.
            BufferedOutputStream out2 = new BufferedOutputStream(out);
            
            // 4백만개의 데이터를 출력해보고, 걸린 시간을 알아보자!
            
            long start = System.currentTimeMillis();
            
            for (int b : data) {
                out2.write(b);
            }
            
            // 버퍼에 남은 마지막 찌끄러기 출력하기
            out2.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            out.close();
            
        }
    }
    
    // BufferedOutputStream
    // => 중간에서 출력할 데이터를 버퍼에 보관하고 있다가
    //    버퍼가 차면 출력 객체를 통해 출력하는 일을 한다.
    // => 이렇게 중간에서 가공하는 일을 하는 클래스를
    //    "Data Processing Stream Class"라고 부른다.
    // => 데코레이터 패턴에서 "데코레이터(Decorator)" 역할을 수행한다.
    // 





// 파일 복사하기  Byte 스트림 응용



    public class Test3_4 {
        public static void main(String[] args) throws Exception {
            
            // FileInputStream 객체를 별도 레퍼런스에 저장하지 않고
            // 바로 BufferedInputStream에 전달한다.
            BufferedInputStream in = new BufferedInputStream(
                    new FileInputStream(new File("sample/jls9.pdf")));
            
            // FileOutputStream 객체를 별도의 레퍼런스에 저장하지 않고
            // 바로 BufferedOutputStream에 전달한다.
            BufferedOutputStream out = new BufferedOutputStream(
                    new FileOutputStream(new File("sample/jls9-4.pdf")));
            
            
            // 데이터를 읽어서 출력한다.
            int b;
            long start = System.currentTimeMillis();
            
            while ((b = in.read()) != -1) {
                // 내부적으로 버퍼에 읽고, 버퍼의 내용을 출력한다.
                out.write(b);
            }
            
            // 버퍼에 남은 잔여 데이터를 출력해야 한다.
            out.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            // 항상 사용을 마친 자원은 해제시킨다.
            // BufferedInputStream을 close() 하면 
            // 이 클래스가 의존하는 FileInputStream도 함께 close() 된다.
            // BufferedOutputStream도 마찬가지이다.
            in.close();
            out.close();
            
            System.out.println("파일 복사 완료했음!");
        }
    }








// Data Processing Stream 바이너리 클래스 사용법 - DataInputStream 사용하기


        DataInputStream in = new DataInputStream(
                                   new FileInputStream("test3.dat"));
        
        s.setName(in.readUTF());
        s.setKor(in.readInt());



// Data Processing Stream 바이너리 클래스 사용법 - DataOutputStream 사용하기

   DataOutputStream out = new DataOutputStream(
                                    new FileOutputStream("test3.dat"));
        
   out.writeUTF(s.getName());







// FileWriter와 FileInputStream의 차이점


    // FileWriter

    public static void main(String[] args) throws Exception {
        // FileReader 
        // => 텍스트 데이터를 읽을 때 사용한다.
        // => read()를 호출하면 텍스트의 형식에 따라 
        //    1 ~ 4바이트를 읽어서 유니코드 2바이트로 변환하여 리턴한다.
        // => 변환규칙
        //    영어 : 1바이트 --> 2바이트 유니코드
        //    UTF-8: 1 ~ 4바이트 --> 2바이트 유니코드 
        
        FileReader in = new FileReader("test.txt");

        int b;
        
        while ((b = in.read()) != -1) {
            System.out.println(Integer.toHexString(b));
        }
        
        in.close();
    }



    // FileInputStream

    public static void main(String[] args) throws Exception {
        // FileInputStream 
        // => 바이너리 데이터를 읽을 때 사용한다.
        // => read()를 호출하면 1바이트를 읽어 리턴한다.
        
        FileInputStream in = new FileInputStream("test.txt");

        int b;
        
        while ((b = in.read()) != -1) {
            System.out.println(Integer.toHexString(b));
        }
        
        in.close();
    }





// FileWriter와 FileOutputStream의 차이점



    // FileWriter

    public static void main(String[] args) throws Exception {
        
        // FileWriter로 텍스트를 출력해보자!
        
        FileWriter out = new FileWriter("test3.txt");
        
        String str = "ABC가각";
        
        // String 객체의 데이터를 파일로 출력할 때
        // 자바의 2바이트 유니코드 값을 
        // JVM 실행 옵션인 "file.encoding"의 값으로 설정된
        // 문자 집합의 규칙에 따라 변환하여 출력한다.
        // 그냥 출력하는 것이 아니다.
        // 인코딩의 기준은 JVM의 file.encoding에 설정된 값을 사용한다.
        // Windows OS => 기본이 MS949
        // MacOS, Linux => 기본이 UTF-8
        // 실행할 때 인코딩을 명시하는 방법
        // => java -cp bin -Dfile.encoding=UTF-8 클래스명
        out.write(str);
        
        out.close();
        
        System.out.println("출력했습니다!");

    }


    // FileOutputStream

    public static void main(String[] args) throws Exception {
        
        // FileOutputStream으로 텍스트를 출력해보자!
        
        FileOutputStream out = new FileOutputStream("test2.txt");
        
        String str = "ABC가각";
        
        // 문자열을 출력하려면 개발자가 직접 바이트 배열을 만들어야 한다.
        byte[] bytes = str.getBytes("UTF-8");
        
        out.write(bytes);
        
        out.close();
        
        System.out.println("출력했습니다!");

    }




     Character 스트림 클래스와 Binary 스트림 클래스
     1) 캐릭터 스트림 클래스
        - Reader/Writer의 서브 클래스들.
        - 보통 클래스 이름이 Reader/Writer로 끝난다.
        - 출력할 때 자바의 유니코드 데이터를 지정한 문자집합의 바이트로 
          변환하여 출력한다.
        - 읽어들일 때 바이트의 값들을 자바의 2바이트 유니코드 값으로 
          변환하여 리턴한다.
        - 주의!
          이미지 파일과 같은 바이너리 파일을 이 클래스를 사용하여 읽으면
          문자로 간주하여 유니코드로 변환한 값을 리턴하기 때문에
          원래의 데이터가 깨지는 문제가 발생한다.
          절대로 이 클래스로 바이너리 데이터를 읽어서는 안된다.
     
     2) 바이너리 스트림 클래스
        - InputStream/OutputStream 의 서브 클래스들.
        - 보통 클래스 이름이 InputStream/OutputStream 으로 끝난다.
        - 데이터를 출력하거나 읽어들일 때 별도의 변환과정 없이
          바이트 단위 그대로 출력하고 읽는다.
        - 이 클래스를 사용하여 텍스트 데이터를 읽을 수 있지만,
          읽은 데이터를 유니코드로 변환하는 과정을 코딩해야 한다.
          불편하다.




// 데이터 프로세싱 스트림 클래스 사용법 - ObjectInputStream / ObjectOutputStream 사용하기



    public static void main(String[] args) throws Exception {
        
        // ObjectInputStream 클래스를 사용하여
        // 파일에 저장된 인스턴스 변수의 값을 읽어 보자!
        ObjectInputStream in = new ObjectInputStream(
                                    new FileInputStream("test1.dat"));
        
        Score2 s = (Score2)in.readObject(); 
        
        in.close();
        
        System.out.println(s);
    }


    public static void main(String[] args) throws Exception {
        
        Score s = new Score("홍길동", 800, 900, 1000);
        
        // ObjectOutputStream 클래스를 사용하여 인스턴스 변수의 값을 
        // 출력해보자!
        ObjectOutputStream out = new ObjectOutputStream(
                                    new FileOutputStream("test0.dat"));
        
        // ObjectOutputStream은 인스턴스 변수의 값을 
        // 바이트 배열로 만들어 출력한다.
        // => "직렬화(serialization)"이라 부른다.
        // 
        // 조건
        // => serialization을 허락해야만 직렬화를 수행할 수 있다.
        //
        // 허락하는 방법?
        // => 클래스 선언부에 java.io.Serializable 규칙을 따른다고 선언!
        //
        out.writeObject(s); // Score 클래스는 직렬화를 허락하지 않았기 
                            // 때문에 실행 오류가 발생한다!
        
        out.close();
        
        System.out.println("출력을 완료했습니다.");
    }





======================================= serialize  ======================================


// 스트림 클래스가 인스턴스 변수의 값을 serialize 할 수 있도록 허락한다.
// => java.io.Serializable 인터페이스를 구현하면 된다.
// => Serializable 인터페이스에는 아무런 메서드가 없다.
//    이 인터페이스의 목적은 단지 어떤 클래스에 대해 
//    직렬화를 허용할 것인지 여부를 지정하기 위해 
//    표시하는 용도로 사용한다.

// serialVersionUID 변수의 용도
// => java.io.Serializable 인터페이스를 구현한 클래스는 
//    자동으로 생성되는 변수이다.
// => 만약 개발자가 serialVersionUID를 지정하지 않는다면 
//    컴파일할 때 컴파일러가 임의의 값으로 설정한다.
// => serialize 데이터의 버전을 구분하기 위해 사용한다.
// => 데이터를 읽는 쪽에서는 데이터에 기록된 클래스의 버전과 
//    자신이 갖고 있는 클래스의 버전을 비교하여  
//    다르다면 예외를 발생시킴으로써 
//    데이터를 잘못 읽는 것을 방지한다.
// 
// => 클래스를 바꾼 후 serialize 한 데이터를 
//    바꾸기 전 클래스로 읽을 수 있게 하려면,
//    serialVersionUID 변수의 값을 일치시키면 된다.
// 

// 인스턴스 변수 중에는 serialize 대상이 되는 필드가 있고,
// 굳이 serialize 할 필요가 없는 필드가 있다.
// 예) 
// music 필드를 추가한 후 Score3의 값을 파일로 출력하였다.
// 데이터를 읽는 쪽에서는 Score3 클래스에 아직 music 필드가 
// 추가되지 않은 상태였다.
// 그러나 데이터를 읽어 출력해보면 합계와 평균은 
// music 데이터 값을 포함한 계산 값이었다. 
// 왜 이런 문제가 발생하였는가?
// 국,영,수,음 외에 합계와 평균도 출력했기 때문에
// 사실 합계와 평균은 과목 점수를 계산하여 나온 값이다.
// 이런 값을 출력하게 되면 
// 읽는 쪽에서 잘못된 결과를 사용할 수 있다.
// 이를 방지하기 위해서 자바에서는 
// serialize 대상에서 필드를 제외시키는 문법을 제공한다.
// => transient modifier 이다. 
// => transient의 사전적 의미를 보면 "일시적인", "잠깐 머무르는"의 
//    뜻을 갖고 있다.
// => 직렬화 대상에서 제외하고 싶은 필드가 있다면 
//    transient를 붙여라!
//    그러면 직렬화할 때 그 값은 제외된다.
//    특히 sum이나 aver 필드처럼 다른 필드의 값을 가지고 
//    도출하는 값인 경우 transient를 붙이도록 하라!
//  

public class Score4 implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int kor;
    private int eng;
    private int math;
    private int music;// 이 필드를 추가한다.
    
    // transient가 붙은 필드의 값을 serialize 되지 않는다.
    transient private int sum;
    private transient float aver;





======================================= Amazon Web Services ======================================



Amazon Web Services  서버   https://aws.amazon.com  무료 계정 생성



모든 서비스 > EC2


단계 1 : Amazon Machine Image 선택  : Amazon Linux AMI 2017.09 (HVM)  선택


단계 2 : General purpose   t2.micro   오른쪽 상단에서 서울 선택  > 검토 및 시작


단계 7 : 시작 클릭


    기존 키 페어 선택 또는 새키 페어 생성 : 새 키페어 생성
    
    키페어 이름 : seoul-amazon

    키페어 다운로드    seoul-amazon.pem 다운로드


    인스턴스 시작 클릭



시작 상태

  서비스 > EC2 > 실행중인 인스턴스

    퍼블릭 IP 확인


   @ seoul-amazon.pem seoul-amazon.ppk 변환

     Parameters > Type of key to generate 에서     RSA 선택

     puttygen 으로 변환  Load 클릭해서 seoul-amazon.pem 선택해서 변환




  @ putty 0.7 연결

  https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html

     MSI (‘Windows Installer’)   putty-64bit-0.70-installer.msi 다운로드


  환경설정

  - Session > Putty Host Name에  퍼블릭 IP  입력

              saved sessions : IP 그냥 입력



 - connection > ssh > auth > private key file for auther 에서 seoul-amazon.ppk 파일 경로 선택

   open 클릭 하고 예(yes) 클릭


 - putty에서  login as : ec2-user              아마존 유저 로그인




  검색 : ec2 apache install    http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/install-LAMP.html

  
  @ Apache Web Server 설치


  [ec2-user ~]$ sudo yum update -y                  sudo (super user do)


  [ec2-user ~]$ sudo yum install -y httpd24 php70 mysql56-server php70-mysqlnd    => LAMP  Apache 웹 서버, MySQL, PHP


  [ec2-user ~]$ sudo service httpd start           Apache 웹 서버를 시작


  [ec2-user ~]$ sudo chkconfig httpd on           Apache 웹 서버가 매번 시스템이 부팅할 때마다 시작되도록 합니다
    

  [ec2-user ~]$ chkconfig --list httpd


  [ec2-user ~]$ runlevel                         linux run level 확인


  인스턴스에서 보안그룹 생성 확인  >   인바운드 22 port 

  편집 > 규칙 추가 > HTTP 선택 저장  80 port 열기    80 port 열면 브라우저로 연결됨

  브라우저에서 퍼블릭 IP 입력 


  [ec2-user ~]$ cd /var     [ec2-user ~]$ cd www    [ec2-user ~]$ ls   [ec2-user ~]$ cd html    [ec2-user ~]$ ls -al


  [ec2-user ~]$ sudo usermod -a -G apache ec2-user            ec2-user 아파치 그룹에 추가

 
  [ec2-user ~]$ exit         ec2-user 아파치 그룹추가 후 로그아웃

  
  [ec2-user ~]$ ec2-user     다시 로그인


  [ec2-user ~]$ groups               ec2-user wheel apache 그룹에 속해있음


  [ec2-user ~]$ sudo chown -R ec2-user:apache /var/www    


  [ec2-user ~]$ ls -al /var/www


  그룹 쓰기 권한을 추가하여 나중에 하위 디렉터리에 대한 그룹 ID를 설정하려면 
  /var/www와 그 하위 디렉터리의 디렉터리 권한을 변경합니다.
  [ec2-user ~]$ sudo chmod 2775 /var/www
  [ec2-user ~]$ find /var/www -type d -exec sudo chmod 2775 {} \;


  그룹 쓰기 권한을 추가하려면 /var/www 및 그 하위 디렉터리의 파일 권한을 반복하여 변경
  [ec2-user ~]$ find /var/www -type f -exec sudo chmod 0664 {} \;



  [ec2-user ~]$ echo "<?php phpinfo(); ?>" > /var/www/html/phpinfo.php


  [ec2-user ~]$ cat /var/www/html/phpinfo.php


  브라우저에서 퍼블릭IP/var/www/html/phpinfo.phs 입력

  
  var/www/html 루트 디렉토리를 삭제하고 입력  > html 하위만 볼 수 있음

  브라우저에서 퍼블릭IP/phpinfo.phs 입력


  [ec2-user ~]$ cd var/www/html


  [ec2-user ~]$ nano index.html       nano edit 실행해서 index.html 편집

      <html>
      <head>
      <title>welcome</title>
      </head>
      <body>
          <h1>welcome to My Page!</h1>
      </body>
      </html>



     ctrl + O      write out

     ctrl + x       exit

     리플레쉬



  [ec2-user ~]$ cat index.html      파일 확인




  https://www.gabia.com/  도메인 등록     가비안 선택   웹호스팅 선택 안함


  상단 mygabia  부가서비스 설정 > DNS 레코드 설정 > 신청

     www.abc.xyz    공인아이피
         abc.xyz    공인아이피   적용




======================================= 소켓 통신 ======================================



Server에서는 개발자가 port 번호 결정   1024번 ~ 49151번: 등록된 포트 (registered port)

Client은 OS 가 port 번호 결정   49152번 ~ 65535번: 동적 포트 (dynamic port)


대기열(Queue Length)은 소켓 생성 개수가 아니다.



- Network 프로그램의 운영순서

. Server : ServerSocket 생성

. Server : 포트감시 시작, Client의 접속을 기다림

. Client : Socket 생성시에 인자 값으로 서버의 IP, PORT를 지정, 서버에 접속 요구

. Server : Client의 요구를 받아 Socket 객체 생성

. Server : 생성된 Socket 객체를 이용해 Client에게 데이터를 보냄

. Client : Socket객체로 데이터를 받고 필요한 데이터를 다시 서버로 전송함












UML과 패턴의 적용   분석 설계


@ UML(Unified Modeling Language)

다른 사람들과의 의사소통 또는 설계 논의
전체 시스템의 구조 및 클래스의 의존성 파악
유지보수를 위한 설계의 back-end 문서

UML: 클래스 다이어그램과 소스코드 매핑 http://www.nextree.co.kr/p6753/




The Art of Computer Programming    도널드 커누스


https://github.com/samchon?tab=repositories


http://blog.eairship.kr/116


http://www.e-cartouche.ch/content_reg/cartouche/formats/en/html/Browser_learningObject1.html



@ 알고리즘 사이트
https://visualgo.net/en

@ 사이트 이동 경로 : breadcrumb

@ cache = Pooling 기법  = Lighting weight


@ 가상 머신 OS별 이미지
http://www.osboxes.org


@ Design Pattern : Best Practice, Gang of Four



http://codingdojang.com/


https://rebeccacho.gitbooks.io/java-study-group/content/index.html


https://www.gitbook.com/


Low Coupling

High Cohesion



프로가 되기 위한 웹기술 입문


Server에서는 개발자가 port 번호 결정   1024번 ~ 49151번: 등록된 포트 (registered port)

Client은 OS 가 port 번호 결정   49152번 ~ 65535번: 동적 포트 (dynamic port)






  

      





  
  





   



















