엄진영 강사 : 010-2634-4150  


(Parentheses:Round Bracket)    [Square Bracket]    <Angle Bracket>    {Brace}



좋은 설계와 디자인 패턴에 대한 더 깊은 지식을 원한다면 아래 책들을 읽어보자.

GOF의 디자인 패턴 - Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides

실전 코드로 배우는 실용주의 디자인 패턴 - Allen Holub

Agile Software Development, Principles, Patterns, and Practices - Robert C. Martin



좋은 설계는 좋은 코드로부터 나온다. 좋은 코드를 작성하는 방법이 궁금하다면 다음 책을 참고하자.

켄트 벡의 구현 패턴 - Kent Beck

이펙티브 자바 - Joshua Bloch

Clean Code 클린 코드: 애자일 소프트웨어 장인 정신 - Robert C. Martin

정규식 테스트 사이트
https://regex101.com/r/Il5IAb/2/

강좌 모음
https://www.inflearn.com/course-cat/development/programing-language/java/

http://www.tutorialspoint.com/
http://www.tutorialspoint.com/design_pattern/factory_pattern.htm

다음은 코드를 점진적으로 개선하고 좋은 설계로 바꿔 나가는데 도움을 주는 책이다.

리팩토링: 코드 품질을 개선하는 객체지향 사고법 - Martin Fowler

테스트 주도 개발: Test-Driven Development - Kent Beck

레거시 코드 활용 전략 - Michael Feathers



마지막으로 작성한 코드의 설계를 공유하거나 설계 초안을 만들 때 사용되는 다이어그램 작성 방법을 빠르게 익히고 싶다면 아래 책이 제격이다.

UML Distilled: 표준 객체 모델링 언어 입문 - Martin Fowler



출처: http://epicdevs.com/14 [Epic Developer]


디자인 패턴
http://plposer.tistory.com/35?category=599723



환경변수 설정 => C:\Program Files\Java\jdk1.8.0_144\bin;

JAVA_HOME :  C:\Program Files\Java\jdk1.8.0_144

%JAVA_HOME%\bin;C:\gradle-4.2\bin;C:\cygwin64\usr\include;C:\cygwin64\bin;C:\oraclexe\app\oracle\product\11.2.0\server\bin;C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\;C:\Program Files\Samsung\AllShare Framework DMS\1.3.23\64bit\;c:\Program Files (x86)\Microsoft SQL Server\90\Tools\binn\;C:\Program Files\nodejs\;C:\Program Files\Git\cmd




@ 프로그램 실행할 때 > 서버에서 참조를 반환했습니다.

  실행파일 또는 바로가기 아이콘 우클릭 > 속성 > 호환성 > 제일밑에 권한 수준 > 관리자 권한으로 이 프로그램 실행 체크 > 적용 > 확인


  실행 파일 바로가기를 C:\Windows\System32폴더에 넣으면  시작 실행에서 실행할 수 있다.

 

 
@ 이클립스설치

  - Eclipse IDE for JavaEE(Enterprise Edition)  Developers 설치



@ 이클립스에서 jdk9 실행 설정

1) eclipse.ini  수정

C:\Users\bit-user\eclipse\jee-oxygen 에서 eclipse.ini  수정


-Dosgi.requiredJavaVersion=1.8
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication

-Dosgi.requiredJavaVersion=1.8



-Dosgi.requiredJavaVersion=9       =====>  수정
-Dosgi.instance.area.default=@user.home/eclipse-workspace
-XX:+UseG1GC
-XX:+UseStringDeduplication
--add-modules=ALL-SYSTEM           =====>  추가
-Dosgi.requiredJavaVersion=9       =====>  수정


2) jdk9 설치 확인

Help  =>  Elclipse Martketplace 에서 Java 9 검색해서 Java 9 Support for Oxygen 4.7 설치

Perferences  =>  Java  =>  Installed JREs  =>  Add 버튼 클릭 =>  Standard VM 선택  
             =>  Next 버튼 클릭 =>  JRE home에서 => Diretory 버튼 클릭해서 jdk-9 폴더 선택


- Java jdk9 설치 확인
- eclipse jdk9 검색



@ workspace 에러 발생할 경우 폴더 이름 변경후 소스 파일 복사
   An error has occured. See the log file
   C:\Users\User\elcipse-workspace\.metadata\.log


@ Run 할때 에러 메시지 처리 :  
 # Exception in thread "main" java.lang.Error: Unresolved compilation problem:
   - Bin 폴더 삭제
   - Projcet => Clean 에서 해당 프로젝트만 Clean



@ Console 한글 깨질 경우

  -. cmd 에서 java -version 확인
  -. 환경변수에서 JAVA-HOME 확인 =>  C:\Program Files\Java\jdk1.8.0_144
  -. 환경변수에서 path 에서 확인 =>  %JAVA_HOME%\bin;
  -. eclipse 폴더에서 eclipse.ini 에서 자바 버전 확인  =>  --add-modules=ALL-SYSTEM 삭제
  -. Window > Preference > Java > Installed JREs 에서 jdk1.8.0_144 확인

  -. Project > Context Menu > Properties > Java Build Path > Libraries Tab 클릭 > 
     > JRE System Library [jdk1.8.0_144] 더블클릭 > Alternate JRE에서 jdk1.8.0_144 를 선택



@ Preferences 설정 

General  =>  Apperance  =>  Theme  =>  Dark

General  =>  Apperance  =>  Colors and Font  =>  Basic  =>  Edit Text
             : 기본 Console Font
             => D2Coding

General => Content Types => Java Class File => Default encoding => UTF-8 => Update

General  =>  Editors  =>  Text Editors
    
             Insert space for tabs
             Show print margin
             Show line numbers
             Show whitespace charaters   Carriage Return, Line Feed 체크 해제
                                         Transparency level( . 투명도)

General => Editors => Text Editors => Spelling => Encoding => Default(UTF-8)

General =>  Workspace  =>  Text file encoing   Other UTF-8 설정

Java  =>  Code Style  =>  Formatter  =>  New 클릭 my 입력후 OK 클릭
                                         Tab policy에서  Spaces only 설정


Web  =>   CSs Files/Htm Files/JSP Files  =>  UTF-8 설정



폰트 d2coding 사용 
  https://github.com/naver/d2codingfont/releases
  "C:\Windows\Fonts\" 경로에 복사

  크롬 기본 글꼴 : 맞춤
  익스플로어 기본 글꼴 : 웹 페이지 글꼴(Gulim), 일반 텍스트 글꼴(GulimChe)



@ View 초기화
  Window => Perspective  => Open Perspective  => Other  => Java EE

@ Eclipse에서 Project Explorer / Navigator  /  Outline / Task List
  Window  =>  Show View  =>  Other  에서 맨위에서 검색






@ Project Import Gradle 사용

    eclipse > eclipse.ini 파일 수정 확인   => 1.8로 복귀
         --add-modules=ALL-SYSTEM  => 삭제
         -Dosgi.requiredJavaVersion=9 => 삭제


1) gradle 명령어 모음

build.gradle             https://docs.gradle.org/4.2.1/userguide/eclipse_plugin.html




java-basic> gradle init --type java-application


java-basic> gradlew tasks --all


java-basic> gradlew EclipseProject


java-basic> gradlew cleanEclipseProject


java-basic> gradlew EclipseClasspath


java-basic> gradlew cleanEclipseProject


java-basic> gradlew Eclipse


java-basic> gradlew cleanEclipse


* gradle 업데이트
C:\workspace\java-web\gradle\wrapper    
distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-bin.zip


2) build.gradle 수정해서 jdk9으로 설정


apply plugin: 'eclipse'


eclipse {
  jdt {
    //if you want to alter the java versions (by default they are configured with gradle java plugin settings):
    sourceCompatibility = 9
    targetCompatibility = 9
    javaRuntimeName = "JavaSE-9"

    file {
      whenMerged { jdt
      }

      withProperties { properties ->
        properties["org.eclipse.jdt.core.compiler.codegen.targetPlatform"] = "9"
        properties["org.eclipse.jdt.core.compiler.source"] = "9"
        properties["org.eclipse.jdt.core.compiler.compliance"] = "9"
      }
    }
  }
}





eclipse {
  jdt {
    sourceCompatibility = 1.8
    targetCompatibility = 1.8
    javaRuntimeName = "JavaSE-1.8"
    
    /*
    file {
      whenMerged { jdt
      }

      // .settings/org.eclipse.jdt.core.prefs 파일에 들어갈 값 설정
      withProperties { properties ->
        properties["org.eclipse.jdt.core.compiler.codegen.targetPlatform"] = "9"
        properties["org.eclipse.jdt.core.compiler.source"] = "9"
        properties["org.eclipse.jdt.core.compiler.compliance"] = "9"
      }
    }
    */
  }
}







3) gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

java-basic> gradlew clean

java-basic> gradlew cleanEclipse

java-basic> gradlew Eclipse


- C:\Users\bit-user\git\bitcamp\java-basic 폴더에서 .classpath 파일에서 JavaSE-9 설정 확인
  	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/
         org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-9/"/>

- C:\Users\bit-user\git\bitcamp\java-basic\.settings 폴더에서 org.eclipse.jdt.core.prefs 확인
  org.eclipse.jdt.core.compiler.codegen.targetPlatform=9
  org.eclipse.jdt.core.compiler.source=9
  org.eclipse.jdt.core.compiler.compliance=9

 - Eclipse
    Project 메뉴 > Build Automatically 체크 확인
    Project 메뉴 > clean 해서 해당 프로젝트만 Clean 클릭해서 청소


4) eclipse 에 Import

File => Import => General => Existing Projects into WorkSpace => Browse(폴더선택)
        - Select root directory : 압축 해제된 프로젝트 폴더
        - Select archive file   : 압축 상태인 프로젝트 압축파일



5) Import 에러

  오류: 기본 클래스 bitcamp.java100.Test16_1을(를) 찾거나 로드할 수 없습니다.
  원인: java.lang.ClassNotFoundException: bitcamp.java100.Test16_1

  Project > Context Menu => Proerties => Java Build Path 에서 jar 경로확인
  git에서 다운 받았기 때문에 Users 가 bit-user로 되어 있음
  노트북은 Users 가 user로 되어 있음

  gradle을 이용해서 .project 파일, .classpath파일과 org.eclipse.jdt.core.prefs 파일 생성

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse

  한 후 다시 Import 한다.


6) Import 의 Project 명이 폴더명과 다른경우(다른 폴더 복사했을 경우)

  - settings.gradle 파일에서 rootProject.name 변경

    rootProject.name = 'bitcamp-java-basic' => rootProject.name = 'java-basic'

  - .project 파일에서 <projectDescription> 변경
 
    <name>bitcamp-java-basic</name>  =>  <name>java-basic</name>


7) Synchronize gradle projects with workspace failed due to an error configuring eclipse

  java-basic> gradlew cleanEclipse

  java-basic> gradlew Eclipse


8) Project 오른쪽 마우스(context menu)  >  Properties > Java Compiler => Version 확인
   
   


* 파일명 변경
 - 윈도우 대소문자 구분하지 않기 때문에 다른 문자를 붙이고 다시 정확하게 입력





@ Eclipse에서 Git 사용   https://backlog.com/git-tutorial/kr/


@ Git Push 및 Pull

  Window  =>  Show View  =>  Other  =>  Git Repositories
  Window  =>  Show View  =>  Other  =>  Git Staging

  Git Repoitories 에서 해당 git에서 오른쪽 Context Menu  =>  Push to Stream

  Git Staging 에서 Unstaged Changes 에서 Staged Changes 로 파일 이동하고
  Commit Message에 메시지 입력

  Commit and Push 클릭해서 로그인

  한번 Commit 하면 이클립스 다시 실행





@ Eclipse에서 Git 자동로그인 해제

  Window  => Preference  =>  General  =>  Security  =>  Secure Storage  =>  Contents Tab에서 삭제
          => Default Secure Strorage => Git  =>  Delete


//==============================================================================================
//* 기타 설정
//==============================================================================================
     
 @ 단축키 등록

 -. Window > Preference > General > Keys > Command에서 File Search 이동 > 
    
    Binding 에 원하는 단축키 클릭 / In Windows > Apply

 
 @ 자동 완성 설정 해제

 -. 자동 완성 해제

    Windows > Preferences > Java > Editor > Content Assist > Enable auto activation : 


 -. 컨텐트 어시트 해제되어 있어도 Ctrl + Space하면 컨텐트 어시트 나타남

 
 @ 괄호 자동 완성 해제

 -. Windows > Preferences > Java > Editor > Typing > Automatically close


========================= 소스 네비게이션 =========================


 -. Ctrl + P  :  Import 추가


 -. Ctrl + \  :  View Move (단축키 사용자 등록  Next View)
 -. Ctrl + [  :  New Package
 -. Ctrl + ]  :  New Class
 -. Ctrl + ;  :  단어 자동완성 (Alt + / , Word Completion, Editing Text)


 -. Shift + F12 : Open Attached Javadoc in a Browser(Shift + F2) 사용자 정의


 -. window > New Window  :  이클립스 새창

 -. Ctrl + M : 현재 활성화된 뷰나 에디터 최대화
 -. Ctrl + F6 : 소스간 이동
 -. Ctrl + F7 : 뷰간 이동 ( 에디터 최대창에서 Project Explorer 창 보인)
    Ctrl + \ (단축키 사용자 등록  Next View)

 -. Ctrl + F8 : 다음 Perspective로 이동(Debug, JavaEE)


 -. Ctrl + E : 소스 탭 이동
 -. Ctrl + F6 : 소스 탭 이동
 -. Ctrl + PageUp, Ctrl + PageDown : 소스탭 이동


 -. Ctrl + , : 현재 커서에서 이전 에러 난 곳으로의 커서 이동
 -. Ctrl + . : 현재 커서에서 이후 에러 난 곳으로의 커서 이동

  

 @ 단축키 등록 보기   [Ctrl + Shift + L]
이클립스 단축키 저장 파일
%workspace%\.metadata\.plugins\org.eclipse.core.runtime\.settings\org.eclipse.ui.workbench.prefs


========================= 소스 코드 편집 =========================


 -. 상위 주석 펼치기 : Window > Preference > Java > Folding > Header Comments



 -. Ctrl + ;  :  단어 자동완성 (Alt + / , Word Completion, Editing Text)
 -. Ctrl + Shift + x : 대문자로
 -. Ctrl + Shift + y : 소문자로



 -. F2 : 에러 소스 위치에서 assist menu
 -. F3(Ctrl + 마우스커서) : 선언된 변수로 이동, 메소드 정의부로 이동
 -. F4         : 클래스명을 선택하고 누르면 해당 클래스의 Hierarchy 를 볼 수 있다.

 -. Ctrl + O   : 해당 소스의 메소드 리스트를 확인하려 할때
 -. Ctrl + Shift + Down : Java Editor에서 다음 member로 이동

 -. Ctrl + Space       :  컨텐트 어시스트

 -. Ctrl + Shift + M : 특정 클래스 Import
 -. Ctrl + Shift + O : 자동으로 Import  => Ctrl + P 로 변경

 -. Ctrl + I : 선택 블록 코드 자동 정리
 -. Ctrl + Shift + F : 전체 코드 자동 정리 

 -. Ctrl + Shift + W : 에디터창 모두 닫기 
 -. Alt + Q  : 에디터창 모두 닫기(단축키 개인 등록, In Windows)
 -. Alt + Z  : 현재 에디터창 제외 모두 닫기(단축키 개인 등록, In Windows)

 -. Ctrl + /           :  주석 토글
 -. Ctrl + Shift + /   :  블록 주석 추가
 -. Ctrl + Shift + \   :  블록 주석 삭제



 -. Alt + Left / Right Arrow  : 이전 소스 위치로 커서 이동
 -. Alt + Up / Down Arrow   : 선택한 소스 위치 변경


 -. Ctrl + Left / Right Arrow  : 문자열 이동
 -. Ctrl + Shift + Left / Right Arrow  : 문자열 선택
 -. Shift + Alt + Left / Right Arrow : 블록 선택 (Up/ Down은 다른 기능)


 -. Shift + Alt + a : 블록 복사 => 마우스가 십자가로 바뀜


 -. Ctrl + F : 현재 파일에서 특정 문자를 찾거나 찾은 문자를 교체하는 방법

 -. Ctrl + Shift + R : 프로젝트에 포함된 리소스(여기서는 파일)중에 찾는 방법

 -. Ctrl + Shift + G : 현재 패키지에 함수를 호출하는 위치를 모두 찾아준다.



 -. 폴딩 설정 : Window > Preference > Java > Editor > Folding
 -. Ctrl + Numpad(-) : 해당소스 폴딩 닫기
 -. Ctrl + Numpad(+) : 해당소스 폴딩 열기

 -. Ctrl + Numpad(/) : 전체 폴딩 닫기
 -. Ctrl + Numpad(*) : 전체 폴딩 열기



 -. Ctrl + H 단축키를 Open Search Dialog열릴때 기본 탭으로 File Search로 변경 :

    Open Search Dialog 단축키는 그대로 두고 File Search 단축키를 Ctrl + H 추가
    
    Open Search Dialog 기본 정보 : Binding(Ctrl + H), When(In Windows)
    


========================= 실행 및 디버깅 =========================

 -. Ctrl + Shift + B : 현 커서의 위치에 브레이크 포인터 설정/해제

 -. F11 : 디버깅 시작

 -. F8 : 디버깅 계속

 -. F6 : 한 줄씩 실행(Step Over)

 -. F5 : 한 줄씩 실행하되 함수일 경우 그 함수 내부로 들어감(Step Into)

 -. Ctrl + R : 디버거 중 현재 라인까지 실행(Run to Line)

 -. Ctrl + F11 : Run 파일 실행
 
 -. Ctrl + R : 현재 라인까지 실행(Run to Line)

 -. F12 : 에디터 활성화

 -. F12 : 컴파일 중 에러등으로 포커스가 다른데로 갔을 때 Editor 로 커서 이동


========================= 코드 템플릿 사용하기 =========================

1. Class에 주석 넣기

   Window > Preferences > Java > Code Style > 
            Code Templates > Comments > Types > Edit 버튼 클릭

   내용 수정
   
/**
 * <pre>
 * ${package_name}
 * ${file_name}
 * </pre>
 *
 * @Author  : ${user}
 * @Date    : ${date}
 * @Version : 
 * ${tags}
 */ 

Refactoring 단축키
Alt + Shift + T : Refactor Quick Menu - 리펙토링 메뉴 바로가기
Alt + Shift + R: 이름 변경(Rename)
Alt + Shift + V : 이동(Move)
Alt + Shift + C : Change Method Signature
Alt + Shift + M : Extract Method
Alt + Shift + L : Extract Local Variable
Alt + Shift + I : Inline

출처: http://fuzzy.tistory.com/171 [퍼지기능의 막가는 블로그]


========================= Refactoring =========================
    

 @ Setters and Getters 자동 추가

    Context Menu > Source > Generate Setters and Getters


 @ Super Class 만들기

   Context Menu > Refactor > Extract SuperClass  => Generalization

 
 @ 기본 Overiding 만들기

   방법1)   클래스 파일에서 Ctrl + Space 한 후 오버라이딩할 메서드 선택 
   
   방법2) 해당 클래스로 가서 F2를 누른후 Add unimplemented methods 클릭


 @ toString(), hashCode(), equals() 오버라이딩 만들기

   Context Menu > Source > Generate toString()

   Context Menu > Source > Generate hashCode() and equals()

   


================================================================


Java SE : Standard Edition
Java ME : Embedded Edition
Java EE : Enterprise Edition


Public Key        Private Key

http://tomcat.apache.org/


@ Codebook
마크다운 : //  =>  //:   

@ 가변 메소드
    static void sum(int... values) {
        int s = 0;
        for (int v : values) {
            s += v;
        }
        System.out.printf("합계: %d\n", s);
    }



        i = 4885223;
        int count = 0;
        int[] cnt = new int[10];
        while(i > 0) {
            cnt[i % 10]++;
            i /= 10;
        }
        
        int x = 0;
        while (x < cnt.length) {
            System.out.printf("%d = %d\n", x, cnt[x]);
            x++;
        }



=================================================================================


@ Java Window 프로그램


        AWT

         |

  Swing  + alpha  =>  SWT

         |

       JavaFX



====================================================================


 -. 클래스 테스트 할 경우 main 함수를 만들어서 테스트한다.

 -. 테스트 한 후 main 삭제하고 run 하면 현재 클래스로 실행된다.

 -. main 이 있는 소스로 이동해서 run을 해야한다.


=====================================================================


@ 클래스 로딩되는 시점

// 1) 클래스 변수를 사용할 때 
//MyClass2.v1 = 200;

// 2) 클래스 메서드를 사용할 때 
//MyClass2.m1();

// 3) new 연산자를 사용할 때
//new MyClass2(); 
        
// 주의!
// => 레퍼런스 변수를 선언할 때는 클래스가 로딩되지 않는다.
// MyClass2 obj1 = null;


public class MyClass2 {
    // static member
    
    // 스태틱 변수 = 클래스 변수
    // => 클래스 이름으로 사용하고, 클래스에 소속된 변수라고 해서
    //    "클래스 변수"라 부른다.
    static int v1 = 100; // 스태틱 변수 = 클래스 변수
    static void m1() { // 스태틱 메서드 = 클래스 메서드
        System.out.println("MyClass2.m1()");
    }
    
    
    // instance member
    int v2 = 200; // 인스턴스 변수
    void m2() { // 인스턴스 메서드
        System.out.println("인스턴스.m2()");
    }
    
}

===================== 메모리 생성 및 해제 =============================


 클래스 static 변수는 Method Area에 생성된다.


 스태틱 변수는 JVM 종료할 때 메모리에서 해제
 스태틱 변수는 JVM 종료할 때 메모리에서 해제하기 때문에 메모리를 많이 차지


 new로 선언된 변수는 인스턴스변수는 무조건 Heap에 만들어진다.
 Heap에 있는 변수는 가비지 컬렉터가 메모리를 해제한다.


 그외는 Local 변수, 로컬에 선언된 레퍼런스 변수는 Stack에 만들어진다.


 인스턴스는 배열을 만들지 못하고 레퍼런스 배열을 만든다.

 클래스 배열을 정의(StatClass[] statclass3 = new StatClass[3];) 하면 statck 메모리에 생성

 메서드만 사용할 경우 인스턴스 변수( statclass3[0] = new StatClass(); )를 선언하지 않아도 된다.

 statclass3[0] = new StatClass(); 정의하면 instance 메모리에 배열의 값이 저장될 인스턴스 메모리가 생성된다.



 static 변수는 this을 붙여도 되나 굳이 붙일 필요가 없다.



=======================================================================


// 스태틱 변수 스태틱 메서드 : 인스턴스 변수 인스턴스 메서드
package bitcamp.java100.ch06.ex6;

import bitcamp.java100.ch06.ex5.Score2;

public class Test9 {
    
    // main(static method) 함수에서 instance variable 사용 불가
    // static class 에서 instance variable 사용 가능
    int ginstvar;
    
    // main(static method) 함수에서 static variable 사용 가능
    // static class 에서 static variable 사용 가능
    static int gstatvar;
    
    // main(static method) 함수에서 instance method 호출 불가
    void ginstMethod() {
        // instance variable 사용 가능
        ginstvar += 100;
        
        // static variable 사용 가능
        gstatvar += 100;
        
        System.out.println("ginstMethod() ginstvar = " + ginstvar);
        System.out.println("ginstMethod() gstatvar = " + gstatvar);
        
        // instance method에서 static method 호출 가능
        gstatMethod();
        

        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classnaem.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    // main 함수에서 static method에서 호출 가능
    // static class에서 호출가능
    static void gstatMethod() {
        // static method에서 instance variable 사용 불가
        //ginstvar = 100;  // 컴파일 오류
        
        // static method에서 static variable 사용 가능
        gstatvar += 100;
        
        //System.out.println("ginstMethod() ginstvar = " + ginstvar);  // 컴파일 오류!
        System.out.println("gstatMethod() gstatvar = " + gstatvar);
        
        // static method에서 instance method 호출 불가
        //ginstMethod();  // 컴파일 오류!
        
        // instance variable / method  선언
        StatClass statclass = new StatClass();
        
        // instance.instance 사용 가능
        statclass.instvar += 100;
        statclass.instMethod();

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass.statvar += 100;
        statclass.statMethod();
        
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!
        
        // classname.static 사용 가능(static method)
        StatClass.statvar += 100;
        StatClass.statMethod();
    }
    
    
    // ***********************************************************
    // non-public, non-static class 선언가능하나 사용할 수 없음
    //class NonStatClass {     // 사용할 수 없음
    //}
    // ***********************************************************
    
    
    static class StatClass {
        // instance variable 초기값은 '0'
        int instvar;

        // static variable 초기값은 '0'
        static int statvar;
        
        // instance method(non-static method)는 this를 내장하고 있다.
        void instMethod() {
            this.instvar += 100;
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            this.statvar += 100;
            
            // instance method 에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            //instMethod();
            // instance method 에서 static method 호출 가능
            statMethod();
            
            System.out.println("instMethod() instvar = " + this.instvar);
            
            // static variable는 this사용 가능 : 권장하지 않음
            // this 생략 권장
            System.out.println("instMethod() statvar = " + this.statvar); 
        }
        
        // static method(class method) 에서 this 사용할 수 없다.
        static void statMethod() {
            // static method에서 instance 내장변수 this 사용 불가
            //this.instvar += 100;  // 컴파일 오류!
            //this.statvar += 100;  // 컴파일 오류!
            
            // static class에서 class 밖에 있는 instance method 호출 불가
            //ginstMethod();    // 컴파일 오류!
            
            // instance method 에서 class 밖에 있는 static method 호출 가능
            // 단, 예제처럼 gstatMethod 함수에서 StatClass 객체나 인스턴스 사용하면 컴파일 오류
            //gstatMethod();  // 컴파일 오류!
            
            
            // static method에서 instance method 호출 불가
            //instMethod();  // 컴파일 오류!
            
            // static method에서 instance variable 사용 불가
            //instvar += 100;  // 컴파일 오류!
            
            // static method에서 static variable 사용 가능
            statvar += 100;
            
            // static method에서 instance variable 사용 불가
            //System.out.println("m2() instvar = " + instvar);  // 컴파일 오류
            System.out.println("m2() statvar = " + statvar);
        }
    }
    
    public static void main(String[] args) {
        //A a = null;
        
        // main(static method) 에서 instance variable / method 사용 불가
        //ginstvar += 100;   // 컴파일 오류!
        //ginstMethod();      // 컴파일 오류!
        
        // main(static method) 에서 static variable / method 사용 가능
        gstatvar += 100;
        gstatMethod();

        System.out.println("gstatvar = " + gstatvar);
        
        
        //######################################################################################
        // instance reference 변수 선언과 동시에 클래스(변수, 메서드)가 Method Area에 로딩된다.
        // Heap에 인스턴스 변수만 메모리 생성되고 인스턴스 메서드는 생성되지 않음.
        // (클래스 메서드 즉 Method Area에 있는 함수를 호출)
        //######################################################################################

        // 인스턴스은 클래스 메서드(Method Area)를 호출한다.   
        // static 붙은 메서드는 클래스명.메서드명()
        // static 없는 메서드는 인스턴스명.메서드명()
        
        // new를 사용해서 instance variable 를 계속 선언하면 힙에 계속해서 인스턴스 메모리가 생성
        StatClass statclass1 = new StatClass();
        StatClass statclass2 = new StatClass();
        

        // instance.instance 사용 가능
        statclass1.instvar += 100;
        statclass1.instMethod();
        
        System.out.println("statclass1.instvar = " + statclass1.instvar);

        // instance.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass2.statvar += 100;
        statclass2.statMethod();
        
        System.out.println("statclass2.statvar = " + statclass2.statvar);
        
        // classname.instance 사용 불가
        //StatClass.instvar += 100;  // 컴파일 오류!
        //StatClass.instMethod();    // 컴파일 오류!

        // classname.static 사용 가능
        StatClass.statvar += 100;
        StatClass.statMethod();
        
        System.out.println("StatClass.statvar = " + StatClass.statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        // 배열을 인스턴스로 정의해야 한다.
        StatClass[] statclass3 = new StatClass[3];  // 객체 주소를 저장할 Stack 메모리 생성
        statclass3[0] = new StatClass();            // 데이터를 저장할 Heap 메모리 생성 
        statclass3[1] = new StatClass();
        statclass3[2] = new StatClass();
        
        // classarray.instance 사용 가능
        statclass3[0].instvar = 100;
        statclass3[0].instMethod();
        
        System.out.println("statclasss[0].instvar = " + statclass3[0].instvar);

        // classarray.static 사용 가능 : 권장하지 않음
        // classname.static 으로 사용 권장
        statclass3[0].statvar = 100;
        statclass3[0].statMethod();
        
        System.out.println("statclass3[0].statvar = " + statclass3[0].statvar);
        
        // 클래스 배열 : 인스턴스를 배열로 만들수 없음
        StatClass[] statclass4 = new StatClass[3];

        // statclass1의 주소를 statclass4[0] 에 저장
	// statclass4[0] = new StatClass(); 가 필요 없다.
        statclass4[0] = statclass1;  
        
        System.out.println("statclass4[0].instvar = " + statclass4[0].instvar);
        System.out.println("statclass4[0].instvar = " + statclass4[0].statvar);
    }
}





================================== 클래스 생성자 =============================================
        

 @ 생성자 : 메모리를 만든후 최소한의 상태를 만드는것

   - 인스턴스를 사용 가능하도록 유효한 상태로 만드는 것

   - 즉 변수의 초기값 설정과 배열의 초기 상태을 만들기 위해서 사용


   - 생성자는 클래스명과 같다(생략 가능하며, 컴파일러가 자동 추가)
     classname () {}

   - 수퍼클래스의 생성자(생략 가능하며, 컴파일러가 자동 추가)
     super();
  

    //생성자 : 메모리를 만든후 최소한의 상태를 만드는것
    //즉 배열의 초기 상태을 만듬

    Score() {
     this.subjects = new int[3];
    }
    
    
    Score(String name, int kor, int eng, int math) {  // 가변 파라미터
     this.name = name;        // this.name(instance variable) 과 name(local variable, method parameter)
     //this.subjects[0] = kor;
     //this.subjects[1] = eng;
     //this.subjects[2] = math;
     
     this.subjects = new int[] {kor, eng, math}; // 초기값 할당과 구분
     
     this.compute();
    }



================================== 클래스 상속(Inheritance) ====================================


  class 클래스명 extends 기존클래스명 {...}

  상속을 해주는 클래스를 "수퍼(super)/부모(parent) 클래스"라고 부른다.

  상속을 받는 클래스를 "서버(sub)/자식(child) 클래스"라고 부른다.

  최상위 수퍼클래스는 Object 클래스이다.

  기존 클래스의 링크 정보를 등록하여 수퍼클래스의 멤버(필드, 메서드)를 상속 받는다.

  수퍼클래스의 멤버(변수, 메서드)를 상속받아 새로운 변수 및 기능을 추가한다.

  수퍼클래스 코드에 문제가 있으면 그 코드를 수정하면 즉시 서브 클래스들은 수정된 코드를 사용하게 된다.

  
  @ 상속의 종류

    1) Specialization

       - 수퍼 클래스를 상속 받아 기능을 추가하여 더 특별한 서브 클래스를 만드는 것.

    2) Generalization

       - 서브 클래스들의 공통 변수나 공통 메서드를 추출하여 수퍼 클래스를 정의하는 것.

       - Context Menu > Refactor > Extract SuperClass  => Generalization



================================== 클래스 캡슐화(Encapsulation) ================================


 클래스 멤버(필드, 메서드)에 접근을 제어하는 기법

 - public    : 같은 패키지와 다른 패키지에 모두 공개
 - protected : 같은 패키지와 다른 패키지에 있는 자손 클래스에게 공개
 - (default) : 같은 패키지에 소속된 클래스에게만 공개
 - private   : 비공개

   public > protected > default > private


 - 패키지 멤버 클래스는 public, default 만 가능하며, 
   패키지에 선언되었기 때문에 같은 패키지만 공개하면 된다.


 - 클래스 안에 선언된 클래스를 "중첩(nested) 클래스"라 부른다.

 - 캡슐화의 존재 이유 : 인스턴스 변수에 무효한 값이 저장되는 것을 방지함으로써 추상화가 무너지는 것을 막는다.

 - 추상화(Abstraction) : 사물이나 사람, 업무 등을 데이터와 메서드로 표현하는 것

 - 필드(주로 값의 입력)를 접근 제한하면 필드의 값을 설정하는 메서드(Setter, Getter)는 전체 공개를 해야하고, 
   외부에서 필요없는 메서드(계산처리)는 접근 제한한다.
  


============== 다형적 변수 (Polymorphism) ================================

 수퍼 클래스의 레퍼런스는 서브 클래스의 인스턴스를 주소를 저장할 수 있다.

 서브 클래스의 인스턴스는 무조건 수퍼 클래스의 인스턴스를 모두 갖고 있기 때문이다.

 이렇게 상속 관계에 따라 한 레퍼런스에 다양한 클래스의 객체 주소를 저장할 수 있다고 해서 "다형적 변수" 라고 부른다.

 구체적인 타입을 지정하기 보다는 그것의 상위 타입을 지정함으로써 
 그 자리에 다양한 타입의 객체를 넣을 수 있다.
 
 public class Car extends Vehicle {}
 public class Truck extends Car {}
 c = new Car();
 c = new Truck();  // Car의 멤버를 사용할 수 있다.

 Sedan c2 = (Sedan)c;  // 명시적 형변환을 해주면 Car의 멤버를 사용할 수 있다.



======================= 오버라이딩 Overrigind(Polymorphism) =====================================


@ 오버라이딩의 메서드 호출

  수퍼클래스의 메서드를 상속받아 메서드 기능을 재정의

  @Override을 메서드명 앞에 붙여 에러를 방지한다.


  오버라이딩 규칙 
    => 접근 범위 : 같거나 확장 (private < default < protected < public)
    => 접근 범위 축소하면 컴파일 오류

    => 리턴 타입 : 반드시 일치
    => 메서드명  : 반드시 일치
    => 파라미터 타입 및 개수 및 순서 : 반드시 일치
    => 파라미터명 : 상관없음

    => 메서드명은 같지만 파라미터의 타입이 다르거나 갯수, 순서가 다른 경우 새 메서드를 추가한것
  

  현재 클래스에 메서드가 정의되었는지 확인하고, 없으면 수퍼 클래스에서 정이 되었는지 확인
  this.compute();   


  현재 클래스가 아니라 수퍼클래스에서 정의되었는지 확인
  super.compute();



  오버라이딩 된 메서드는 호출되는 것은 클래스의 인스턴스 주소에 따라서 결정


  HashSet은 ArrayList 나 MashMap, HashTable 처럼 객체의 주소를 보관

  HashSet는 개체의 주소를 중복해서 보관하지 않는다.


  Object에서 상속받은 toString(), hashCode(), equals() 함수를 오버라이딩 해서 사용
  
  toString() : 인스턴스 변수의 값을 확인

  hashCode(), equals() : 인스턴스의 변수의 값이 같은지 확인


  StringBuffer는 equals()를 재정의하지 않았기 때문에 Object의 equals()를 그대로 사용한다.

  hash값 : 각 인스턴스를 구분할 때 사용할 디지털 지문!



========================= 오버로딩 Overloading(Polymorphism) =================================


  파라미터의 갯수, 타입, 순서가 다르더라도 같은 기능을 수행하는 메서드에 
  같은 이름을 부여하여 사용할 수 있게하는 문법

  메서드 호출 구분은 갯수, 타입, 순서로 구분한다. 

  리턴 값을 받느냐 안 받느냐로 호출할 메서드를 구분할 수 없다.

  리턴 타입만 다른 메서드는 추가할 수 없고, 파라미터의 갯수, 타입, 순서가 다르게 해야한다.

  파라미터 타입이 메서드와 다를 때는 암시적 타입 캐스팅으로 가능한 메서드를 호출한다.

  수퍼 클래스에서 상속 받은 메서드와 이름은 같지만 파라미터가 다른 메서드를 추가하면 오버로딩이다.




======================================= 제네릭(Generic) =====================================

  제테릭이 적용된 클래스를 사용하면 여러 개의 클래스를 만들 필요가 없이

  하나의 클래스로 여러 타입의 객체를 사용할 수 있다.


  제네릭을 사용하는 이유는 타입의 안정성을 제공하고, 타입체크와 형변환을 생략하여 코드가 간결하다.

  선언할 수 있는 타입은 객체 타입과, wrapper(primitive 변수의 객체) 클래스만 가능하다


  클래스가 어떤 데이터 타입을 사용할 것인지 타입명을 받는다
  
  Type의 약자인 T를 주로 사용

  E - Element (used extensively by the Java Collections Framework)
  K - Key
  N - Number
  T - Type
  V - Value
  S,U,V etc. - 2nd, 3rd, 4th types


  Stack<Contact> contacts = new Stack<>();
  contacts.push(new Contact("홍길동", "hong@test.com", "1111-1111"));  // Contact 생성자

  public class Stack<T> {
    
    // 그리고 사용자가 전달한 타입의 이름을 코드 곳곳에 지정하면 된다.
    private class Box {
        T value;
        Box next;
        
        public Box() {}
        
        public Box(T value) {
            this.value = value;
        }
    }
    
    public void push(T value) {
        // 새 상자를 만들어 값을 저장한다.
        Box box = new Box(value);
    }
  }

  Iterator<제네릭 타입> interator = list.iterator();

  ex) List 계열, Set 계열
      ArrayList<Score> list = new ArrayList<>();
      Iterator<Score> iterator = list.iterator();

     
  ex) Map 계열
      HashMap<String, Contact> map = new HashMap<>();
      Iterator<Contact> iterator = map.values().iterator();

      while(iterator.hasNext()) {
          System.out.println(iterator.next());
          iterator.remove();
      }

//==============================================================================================
//* @SuppressWarnings Annotation
//==============================================================================================

  

    @SuppressWarnings("unchecked")
    T get(int index) {
        if (index < 0 || index >= this.cursor) {
            return null;
        }
        return (T)this.list[index];
    }

    return (T)this.list[index]; => 
      => 제네릭 하면서 타입 캐스팅에 확신이 없을 때 
         커서를 소스위에 올리고(단축키 F2)  add @SuppressWarnings("unchecked") 추가


    1. all : 모든 경고를 억제
    2. cast : 캐스트 연산자 관련 경고 억제
    3. dep-ann : 사용하지 말아야 할 주석 관련 경고 억제
    4. deprecation : 사용하지 말아야 할 메소드 관련 경고 억제
    5. fallthrough : switch문에서의 break 누락 관련 경고 억제
    6. finally : 반환하지 않는 finally 블럭 관련 경고 억제
    7. null : null 분석 관련 경고 억제
    8. rawtypes : 제네릭을 사용하는 클래스 매개 변수가 불특정일 때의 경고 억제
    9. unchecked : 검증되지 않은 연산자 관련 경고 억제
    10. unused : 사용하지 않는 코드 관련 경고 억제




============================== @Deprecated Annotation ====================================

    
 -. @Deprecated : 기존에 만든 메서드는 현재 여러곳에 사용중이기 때문에 그대로 두고

    메서드 사용하지 않도록 경고하고 기능이 같은 메서드를 구현해서 사용하도록한다.

    @Deprecated
    public void move() {
        // move의 기능을 run()으로 옮기고, 여기서는 run()을 호출한다.
        this.run();
        
        // 즉 move() 메서드는 예전에 만든 프로젝트를 위해 run()의 껍데기 역할을 한다.
    }
    
    // 신규 프로젝트에서는 run()을 사용해야 하기 때문에 
    // 수퍼클래스에서 상속 받은경우 run()을 오버라이딩한다.
    @Override
    public void run() {
        System.out.println("간다.");
    }


======================================= 컬렉션 프레임워크 =====================================

  컬렉션즈 프래임워크라는 것은 다른 말로는 컨테이너라고도 부른다. 
  즉 값을 담는 그릇이라는 의미이다. 그런데 그 값의 성격에 따라서 컨테이너의 성격이 조금씩 달라진다. 
  자바에서는 다양한 상황에서 사용할 수 있는 다양한 컨테이너를 제공하는데 
  이것을 컬렉션즈 프래임워크라고 부른다.

  
  List : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
         ArrayList, LinkedList, Stack, Queue


  Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
        HashSet, TreeSet


  Map : 키와 값의 쌍으로 이루어진 데이터의 집합. 
        순서는 유지되지 않으며, 키는중복을 허용하지 않고, 값을 중복을 허용한다. 
        HashMap, Hashtable, TreeMap,
   
  toArray
        값을 배열로 꺼내고 싶다면, 값을 모두 담을 수 있는 배열을 만든 다음에,
        toArray()의 파라미터로 배열 주소를 넘겨라!
        그러면 배열에 객체들의 주소를 담아줄 것이다.
        만약 파라미터로 제공된 배열을 크기가 HashSet에 보관된 객체들의 수 보다 작다면,
        따로 배열을 새로 만든 다음에 그 배열의 주소를 리턴할 것이다.
	
        HashSet<String> set = new HashSet<>();

        String[] arr1 = new String[set.size()];
        String[] arr2 = set.toArray(arr1);

        String[] arr = set.toArray(new String[set.size()]);


        // ArrayList
        Iterator<String> iterator = list.iterator();
        

        // HashSet
        Iterator<String> iterator = set.iterator();


        // HashMap
        Iterator<Contact> iterator = map.values().iterator();

    
        // 값 출력
        while(iterator.hasNext()) {
            System.out.println(iterator.next());
        }



     arr[cursor++] = 80;   // Auto_Boxing => new Integer(80)




========================== 이터레이터(Iterator) 인터페이스 객체 ==========================

- 모든 컬렉션(Collection)으로 부터 정보를 얻을 수 있는 인터페이스 입니다.

  public interface Iterator {
    boolean hasNext();
    Object next();
    void remove();
  }



 ArrayList<String> list = new ArrayList<>();
 Iterator<String> iterator = list.iterator();

 - iterator() 메서드의 의미?
   => iterator()는 Iterator 인터페이스를 구현한 어떤 클래스의 인스턴스를 만들어 리턴한다.
   => iterator()는 Iterator 인터페이스를 구현한 어떤 클래스의 객체를 리턴한다.
   => iterator()는 Iterator 인퍼페이스를 구현한 객체를 리턴한다.
   => iterator()는 Iterator 구현체를 리턴한다.
   => iterator()는 Iterator 객체를 리턴한다.



===================== 추상클래스 ====================================

-. 서브 클래스가 사용할 필드와 메서드를 물려주는 역할을 한다.

-. 추상 클래스로 선언하면 직접 인스턴스를 생성할 수 없다.(//Car car = new Car(); // 컴파일 오류!)


    # 추상클래스와 추상메서드
    
    public abstract class Car {
        
        // 추상클래스에는 기본적인 필드와 메서드를 선언
        String model;
        int cc;
        
        public void stop() {
            System.out.println("멈춘다.");
        }
        
        // Car의 모든 서브 클래스는 반드시 추상메서드를 구현해야한다.
        // 추상클래스(수퍼클래스)에서는 구현하면 안된다.
        public abstract void run();
    }
    
    
    public class Sedan extends Car {
        
        boolean isOpen;
        
        // 오버라이딩 하는 메서드는 가능한 애노테이션을 붙인다.
        // 자동 생성 : Sedan에 커서 이동하여 F2키를 누르고 'add unimplemented methods' 클릭
        @Override
        public void run() {
            if (isOpen) {
                System.out.println("시원하게 달린다.");
            }
        }
        
        public void openSunroof() {
            System.out.println("썬루프 연다.");
        }
        
        public void closeSunroof() {
            System.out.println("썬루프 닫는다.");
        }
    }



    # 추상메서드와 인스턴스 메서드 사용
    
    public abstract class A {
        int v1;
        
        public void m1() {
            System.out.println("A.m1()");
        }
    }
    
    public class B extends A {
        int v2;
        
        public void m2() {
            System.out.println("B.m2()");
        }
    }
    
    
    public class Test {
        public static void main(String[] args) {
            // 추상 클래스의 서브 클래스를 사용한다.
            B obj = new B();
            obj.m1();
            obj.m2();
            
            System.out.println("----------------------------");
            
            // 물론 레퍼런스를 만들 때는 추상 클래스도 사용할 수 있다.
            A obj2 = new B();
            
            // 다만 obj2로 사용할 수 있는 메서드는
            // obj2 타입에 제한된다.
            obj2.m1();
            //obj2.m2(); // 컴파일 오류!
            
            // obj2에는 실제 B 객체(의 주소)가 저장되어 있다.
            // B의 원래 기능을 쓰고 싶다면, 형변환하라!
            ((B)obj2).m2();
            
            B obj3 = (B)obj2;
            obj3.m2();
        }
    }




======================================= 인터페이스 ======================================


 -. 인터페이스는 사용자(caller)와 사용되는자(callee) 사이의 호출 규칙을 정의할 때 사용하는 문법이다.


    public interface Protocol{
	// 필드는 상수만 가능
        public static final float PI = 3.14159f;
        
        // => public 을 생략할 수 있다.
        static final int AA = 100;
        
        // => static 을 생략할 수 있다.
        final int BB = 200;
        
        // => final을 생략할 수 있다.
        int CC = 300;


        // 호출 규칙이라함은 메서드를 의미한다.
        // 추상메서드이고, abstract가 생략해도 컴파일러가 자동 생성    
        /*public abstract*/ void m1();
        void m2();
    }

    public class Callee implements Protocol {
	// 인터페이스에 선언된 모든 추상 메서드를 반드시 구현
    	// 자동 생성 : Callee 에 커서 이동하여 F2키를 누르고 'add unimplemented methods' 클릭
        @Override
        public void m1() {
            System.out.println("m1()...");
        }

        @Override
        public void m2() {
            System.out.println("m2()...");

            // 인터페이스의 상수 값을 직접 사용할 수 있다.
            System.out.println(Protocol3.AA);
        }
    }



 -. 인터페이스를 구현한 클래스를 상속 받은 모든 자손 클래스들은 그 인터페이스를 구현한 것이 된다.

    public class Test extends Callee  {
        void m3() {
            System.out.println("m3()");
        }
    }



 -. 클래스는 다중 상속은 불가능하지만 다중 구현은 가능하다.


    public class Test3 implements A, C {
        
        // A의 m1()과 C의 m1()을 동시에 만족시킨다.
        @Override public void m1() {System.out.println("m1()");}
        
        // C의 m3()를 구현한 것이다. 
        @Override public void m3() {System.out.println("m3()");}
        
    }


 -. 인터페이스에서 다중 상속이 불가능한 경우

   public interface Test4 extends A, E {


 -. 인터페이스에서 다중 구현이 불가능한 경우





 -. default 문법 (JDK 8에서 추가)

    // 객체 사용하기 전에 준비 시키는 메서드
    default void init() {};
    
    // 프로그램을 종료하기 전에 객체에게 마무리 작업을 시키는 메서드
    default void destroy() {};
    
    // default : 인터페이스에 새 규칙이 추가될 경우 기존 소스는 에러가 발생하므로,
		 새규칙을 추가하려면 수정 작업이 많아지므로,
                 규칙을 따르지 않게 하기 위해서 default 문법을 도입





======================================= 예외 처리 ======================================


    Object - Throwable - Error - LinkageError, ThreadDeath, VirtualMachineError

                       - Exception - RuntimeException - ArithmeticException, 
                                   |                  - NullPointerException
                                   |                  - IndexOutOfBoundException
                                   |                  - SecurityException
                                   |
                                    - IOException     - EOFException
                                                      - FileNotFoundexception
                                                      - InterrupedIOException
                                                      - CloseNotFoundException



 예외의 종류: 
 1) try...catch... 사용을 강제하지 않는 예외
    => Error와 RuntimeException(Exception의 서브 클래스) 계열의 예외
    => try...catch...로 예외를 처리하지 않더라도 컴파일 오류는 아니다!
 
 2) try...catch... 사용을 강제하는 예외
    => Exception 계열의 예외 
    => 즉 try...catch로 예외를 처리하지 않으면 컴파일 오류 발생!


 3) try...catch...finally
    -. finally 블록은 try 블록을 나가기 전에 반드시 실행한다.
    -. catch 블록 없이 사용할 수 있다.
    -. 사용한 자원을 자동으로 해제시킬때 사용

    PrintWriter out = null;
    try {
        out = new PrintWriter(new FileWriter("OutFile.txt"));
        ...
    } catch (IOException e) {
        ...
    } finally {
        if (out != null) 
            out.close();
    }


 4) try-with-resources (JDK 7 추가문법)

        try (
            // java.lang.AutoCloseable 규칙에 따라 만든 클래스의 객체여야 한다.
            // AutoCloseable 인터페이스를 구현한 클래스는 사용할 수 있다.
            // ( class MyClass implements AutoCloseable {   =>  블록에 close() 메서드 오버라이딩 )
            // FileWriter AutoCloseable 구현체( AutoCloseable 규칙에 따라 close() 메서드가 있다)
             MyClass obj = new MyClass()
        ) {
            System.out.println("try 블록 실행");
            
            switch (str) {
            case "a": throw new Exception();
            case "b": throw new IOException();
            case "c": throw new FileNotFoundException();
            case "d": throw new SQLException();
            }
            
            System.out.println(str);  
        } catch (IOException|SQLException e) {
            // 파라미터를 선언할 때 자식 클래스부터 나열
            // 형제 관계의 예외 클래스는 이렇게 OR 연산자를 사용하여
            // 파라미터 타입을 나열할 수 있다.
            System.out.println("IOException|SQLException 예외 처리");
            
        } catch (Exception e) {
            // 예외 클래스 중에서 수퍼 클래는 이렇게 별도로 선언한다.
            System.out.println("Exception 예외 처리");
        }



 5) 커스텀 예외 클래스를 이용하여 예외를 구분하기


    // 특별한 예외 클래스를 정의한다.
    public class EmptyStringException extends Exception {
        public EmptyStringException() {
            super(); // 그냥 수퍼 클래스의 기본 생성자를 호출한다.
        }
    
        public EmptyStringException(String message) {
            super(message); // 그냥 수퍼 클래스의 메시지를 받는 생성자를 호출한다.
        }
    
        // 그 밖에 필드나 메서드를 추가할 필요가 없다.
        // 이 클래스의 목적은 클래스 타입으로 예외를 구분하기 위함이다.
        // 단 간단한 메시지는 저장할 수 있도록 생성자를 정의하라!
    
    }


    static void input() throws Exception {
        Score score = new Score();
        
        System.out.print("이름? ");
        score.name = keyScan.nextLine();
        
        if (score.name.length() == 0) {
            // 예외 객체를 던진다.
            throw new EmptyStringException("이름이 빈 문자열입니다.");
        }
        
        System.out.print("국어? ");
        score.kor = Integer.parseInt(keyScan.nextLine());
        if (score.kor < 0 || score.kor > 100)
            // 예외 객체를 던진다.
            throw new ScoreOutOfBoundsException();
        
        list.add(score);
    }


    public static void main(String[] args) {
        while (true) {
            // input()에서 예외 클래스를 이용하여 예외 상황을 전달하기 때문에 
            // input()을 호출하는 쪽에서는 catch 블록으로 예외를 쉽게 구분할 수 있다.
            try {
                input();
                // 다음과 같이 예외가 발생할 때 클래스 타입으로 구분하기 때문에
                // 코드를 해석하기 쉽다. 즉 유지보수가 쉽다.
            } catch (EmptyStringException e) {
                System.out.println("입력 문자열이 비어 있습니다.");
                
            } catch (ScoreOutOfBoundsException e) {
                System.out.println("점수의 범위를 벗어났습니다.");
                
            } catch (NumberFormatException e) {
                System.out.println("숫자 형식이 아닙니다.");
                
            } catch (Exception e) {
                // 기타 예외는 어떤 상황인지 유추하기 힘들다.
                // 이런 경우 어디에서 예외가 발생했는지 상세하게 조사할 필요가 있다.
                // 이때 사용하는게 호출 단계를 출력해 보는 것이다.
                e.printStackTrace();
            }
        }
    }





======================================= 익명클래스 ======================================

  인터페이스 클래스 구현체 > 중첩 클래스 > 로컬 클래스 
                           > 익명 클래스(인터페이스, 수퍼클래스 생성자) > 익명클래를 함수안에 추가


 

  1) FileNameFilter을 MyFileNameFilter 클래스로 구현

        
    public class Test5_1 {
    
        public static void main(String[] args) {
            
            File file = new File(".");
    
            // 디렉토리에 들어 있는 파일이나 디렉토리 이름을 알아낼 때 
            // 특정 조건에 부합하는 이름만 꺼내고 싶을 때가 있다.
            // 그럴 때 list()의 파라미터로 필터 기능을 수행하는 객체를 
            // 전달하라! 이름을 꺼낼 때 그 필터를 사용하여
            // 리턴하는 배열에 포함할지 여부를 결정한다.
            //
            // ver 1: list()에서 사용할 필터 클래스는 패키지 멤버로 만든다.
            // => 오직 이 클래스에서만 사용하는 클래스인데
            //    굳이 패키지 멤버로 만들 필요가 있을까?
            String[] filenames = file.list(new MyFilenameFilter());
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }


    public class MyFilenameFilter implements FilenameFilter {
    
        @Override
        public boolean accept(File dir, String name) {
            File file = new File(dir, name);
            if (file.isDirectory())
                return true;
            else 
                return false;
        }
    }



  2) 중첩클래스

    
    public class Test5_2 {
    
        // 파일만 걸러내는 필터
        static class MyFilenameFilter implements FilenameFilter {
            @Override
            public boolean accept(File dir, String name) {
                File file = new File(dir, name);
                if (file.isDirectory())
                    return false;
                else 
                    return true;
            }
        }
        
        public static void main(String[] args) {
            
            File file = new File(".");

            // ver 2: list()에서 사용할 필터 클래스를 중첩 클래스로 만든다.
            // => 오직 이 클래스에서만 사용하는 클래스로 선언한다.
            String[] filenames = file.list(new MyFilenameFilter());
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }



  3) 로컬 클래스

    
    public class Test5_3 {
    
        public static void main(String[] args) {
            // 파일명이나 디렉토리명이 .으로 시작하는 경우는 
            // 결과에서 제외하자!
            class MyFilenameFilter implements FilenameFilter {
                @Override
                public boolean accept(File dir, String name) {
                    if (name.startsWith("."))
                        return false;
                    else 
                        return true;
                }
            }
            
            File file = new File(".");

            // ver 3: list()에서 사용할 필터 클래스를 로컬 클래스로 만든다.
            // => 오직 이 클래스의 main()에서만 사용하는 클래스로 선언한다.
            String[] filenames = file.list(new MyFilenameFilter());
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }





  4) 익명 클래스(인터페이스, 수퍼클래스 생성자)
    
    public class Test5_4 {
    
        public static void main(String[] args) {
            // .으로 시작하는 파일이나 디렉토리만 결과에 포함시킨다.
            FilenameFilter filter = new FilenameFilter() {
                @Override
                public boolean accept(File dir, String name) {
                    if (name.startsWith("."))
                        return true;
                    else 
                        return false;
                }
            };
            
            File file = new File(".");

            // ver 4: list()에서 사용할 필터 클래스를 익명 클래스로 만든다.
            // => 오직 한 개의 객체만 생성할 클래스라면 익명 클래스로 
            //    만들어도 된다.
            String[] filenames = file.list(filter);
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }




  5) 익명클래를 함수안에 추가(안드로이드에서 주로 사용)

    
    public class Test5_5 {
    
        public static void main(String[] args) {
            File file = new File(".");

            // ver 5: list()에서 사용할 필터 클래스를 익명 클래스로 만든다.
            // => 단 저 위에 멀리 익명 클래스의 코드를 두지 말고,
            //    그 익명 클래스를 사용하는 코드 가까이에 두어라.
            //
            String[] filenames = file.list(new FilenameFilter() {
                @Override
                public boolean accept(File dir, String name) {
                    if (name.startsWith("."))
                        return true;
                    else 
                        return false;
                }
            });
            
            for (String name : filenames) {
                System.out.println(name);
            }
        }
    
    }




======================================= 파일 구분 ======================================



     파일 쓰기: Byte 스트림 사용 => 바이너리 파일 쓰기
     바이너리 파일
     - 메모장과 같은 텍스트 편집기로 유효한 편집할 수 없는 파일 
     - 전용 편집기가 필요하다.
     - 예) .hwp, .doc, .xls, .ppt, .avi, .mp3, .exe, .class, .psd,
           .gif, .jpeg, .tiff 등
     
     텍스트 파일
     - 메모장과 같은 단순 텍스트 편집기로 편집할 수 있는 파일
     - 문자집합에 따라 인코딩된 바이트 데이터이다.
     - 예) .txt, .csv, .html, .css, .js, .c, .cpp, .rtf, .bat, .sh 등
     
     인코딩(encoding)
     - 어떤 규칙에 따라 특정 바이트 값으로 변환하는 것.
     - 예) 아날로그로 입력된 소리 ==> .wav 파일 생성
       예) 일반 데이터를 ==> 암호화데이터 
       예) .bmp ==> .jpeg
    
     디코딩(decoding)
     - 어떤 규칙에 따라 원래의 값으로 변환하는 것.
     - 예) .jpeg ==> .bmp
       예) 암호화된 데이터 ==> 원래 데이터
    




======================================= 파일 입출력 ======================================





 입출력을 다루는 클래스의 분류
 1) Data Sink Stream 클래스
 => 데이터를 저장소에 직접 저장하고 읽는 클래스이다.

 => 바이너리 스트림 클래스 예)  InputStream / OutputStream 의 서브 클래스들
    - 2 바이트 유니코드 값으로 변환

    - FileInputStream/FileOutputStream => 파일    바이트 단위로 데이터를 읽는다
    - ByteArrayInputStream/ByteArrayOutputStream => 메모리
    - PipedInputStream/PipedOutputStream => 다른 프로그램(프로세스)

 => 캐릭터 스트림 클래스 예)  Reader / Writer 종류
    - 변환과정 없이 바이트 값으로 출력(File Foramt으로 데이타 분석)

    - FileReader/FileWriter => 파일 
    - CharArrayReader/CharArrayWriter => 메모리 
    - StringReader/StringWriter => 메모리 
    - PipedReader/PipedWriter => 다른 프로그램(프로세스)
 

 2) Data Processing Stream 클래스 
 => 읽은 데이터 또는 출력할 데이터를 가공하는 클래스이다.

 => 바이너리 스트림 클래스 예)    InputStream / OutputStream 의 서브 클래스들
    - BufferedInputStream/BufferedOutputStream
    - DataInputStream/DataOutputStream
    - ObjectInputStream/ObjectOutputStream
    - PrintStream
 
 => 캐릭터 스트림 클래스 예)     Reader / Writer 종류
    - BufferedReader/BufferedWriter
    - LineNumberReader
    - FilterReader/FilterWriter
    - PrintWriter




 1) Data Sink Stream 클래스

        // 1) 바이트 단위로 데이터를 읽어주는 객체 준비
        FileInputStream in = new FileInputStream(
                                    new File("sample/a.jpg"));
        
        // 2) 바이트 단위로 데이터를 출력할 객체 준비
        FileOutputStream out = new FileOutputStream(
                                    new File("sample/a2.jpg"));
                
        
        // 3) 바이트를 읽어서 그대로 출력한다.
        int b; 
        while ((b = in.read()) != -1) {
            out.write(b);
        }
        
        // 4) 항상 사용을 마친 자원은 해제시킨다.
        in.close();
        out.close();
        



// 데코레이터(Decorator)


    // 상속을 이용하여 기능을 확장하는 대신에
    // 기존 객체를 포함하고 여기에 기능을 덧붙이는 형태! 
    public class MyBufferedInputStream2 {
        
        // 왜 InputStream 레퍼런스를 선언했는가?
        // => InputStream 레퍼런스는 FileInputStream 외에도 
        //    그 하위 클래스의 모든 객체를 가리킬 수 있기 때문이다.
        // => 즉 더 많은 종류의 객체를 포함하기 위해서 이 타입으로 선언했다.
        InputStream worker;
        
        byte[] buf = new byte[8192];
        int len; // 버퍼에 저장한 바이트 개수
        int cursor; // 버퍼에서 읽을 바이트 위치
        
        public MyBufferedInputStream2(InputStream worker) {
            this.worker = worker;
        }
        
        public int read() throws IOException {
            if (cursor >= len) { // 버퍼가 비었으면 다시 버퍼를 채운다.
                cursor = 0; // 커서는 다시 0으로 초기화시킨다.
                len = worker.read(buf);
                if (len == -1) // 파일에서 읽을 데이터가 없다면 
                    return -1;
            }
            
            return buf[cursor++] & 0x000000FF;
        }
    }




    public class Test2_5 {
        public static void main(String[] args) throws Exception {
            
            // 데이터 준비 
            // => 랜덤 메서드를 사용하여 임의의 값을 400만개를 준비한다.
            int[] data = new int[4000000];
            
            for (int i = 0; i < data.length; i++) {
                data[i] = (int)(Math.random() * 100000);
            }
            
            // 파일에 출력할 객체 생성
            FileOutputStream out = new FileOutputStream("./test3.dat");
            
            // 중간에서 버퍼 기능을 제공할 객체 생성
            // 실제 출력하는 일은 위에서 생성한 FileOutputStream이 할 것이다.
            MyBufferedOutputStream2 out2 = new MyBufferedOutputStream2(out);
            
            // 4백만개의 데이터를 출력해보고, 걸린 시간을 알아보자!
            
            long start = System.currentTimeMillis();
            
            for (int b : data) {
                out2.write(b);
            }
            
            // 버퍼에 남은 마지막 찌끄러기 출력하기
            out2.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            out.close();
            
        }
    }
 






// Data Processing Stream 캐릭터 스트림 클래스 사용법 

      

      BufferedInputStream 


      public class Test3_4 {
        public static void main(String[] args) throws Exception {
            
            // FileInputStream 객체를 별도 레퍼런스에 저장하지 않고
            // 바로 BufferedInputStream에 전달한다.
            BufferedInputStream in = new BufferedInputStream(
                    new FileInputStream(new File("sample/jls9.pdf")));
            
            // FileOutputStream 객체를 별도의 레퍼런스에 저장하지 않고
            // 바로 BufferedOutputStream에 전달한다.
            BufferedOutputStream out = new BufferedOutputStream(
                    new FileOutputStream(new File("sample/jls9-4.pdf")));
            
            
            // 데이터를 읽어서 출력한다.
            int b;
            long start = System.currentTimeMillis();
            
            while ((b = in.read()) != -1) {
                // 내부적으로 버퍼에 읽고, 버퍼의 내용을 출력한다.
                out.write(b);
            }
            
            // 버퍼에 남은 잔여 데이터를 출력해야 한다.
            out.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            // 항상 사용을 마친 자원은 해제시킨다.
            // BufferedInputStream을 close() 하면 
            // 이 클래스가 의존하는 FileInputStream도 함께 close() 된다.
            // BufferedOutputStream도 마찬가지이다.
            in.close();
            out.close();
            
            System.out.println("파일 복사 완료했음!");
        }
    }


    

    BufferedOutputStream 


    public class Test2_6 {
        public static void main(String[] args) throws Exception {
            
            // 데이터 준비 
            // => 랜덤 메서드를 사용하여 임의의 값을 400만개를 준비한다.
            int[] data = new int[4000000];
            
            for (int i = 0; i < data.length; i++) {
                data[i] = (int)(Math.random() * 100000);
            }
            
            // 파일에 출력할 객체 생성
            FileOutputStream out = new FileOutputStream("./test3.dat");
            
            // 중간에서 버퍼 기능을 제공할 객체 생성
            // 실제 출력하는 일은 위에서 생성한 FileOutputStream이 할 것이다.
            BufferedOutputStream out2 = new BufferedOutputStream(out);
            
            // 4백만개의 데이터를 출력해보고, 걸린 시간을 알아보자!
            
            long start = System.currentTimeMillis();
            
            for (int b : data) {
                out2.write(b);
            }
            
            // 버퍼에 남은 마지막 찌끄러기 출력하기
            out2.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            out.close();
            
        }
    }
    
    // BufferedOutputStream
    // => 중간에서 출력할 데이터를 버퍼에 보관하고 있다가
    //    버퍼가 차면 출력 객체를 통해 출력하는 일을 한다.
    // => 이렇게 중간에서 가공하는 일을 하는 클래스를
    //    "Data Processing Stream Class"라고 부른다.
    // => 데코레이터 패턴에서 "데코레이터(Decorator)" 역할을 수행한다.
    // 





// 파일 복사하기  Byte 스트림 응용



    public class Test3_4 {
        public static void main(String[] args) throws Exception {
            
            // FileInputStream 객체를 별도 레퍼런스에 저장하지 않고
            // 바로 BufferedInputStream에 전달한다.
            BufferedInputStream in = new BufferedInputStream(
                    new FileInputStream(new File("sample/jls9.pdf")));
            
            // FileOutputStream 객체를 별도의 레퍼런스에 저장하지 않고
            // 바로 BufferedOutputStream에 전달한다.
            BufferedOutputStream out = new BufferedOutputStream(
                    new FileOutputStream(new File("sample/jls9-4.pdf")));
            
            
            // 데이터를 읽어서 출력한다.
            int b;
            long start = System.currentTimeMillis();
            
            while ((b = in.read()) != -1) {
                // 내부적으로 버퍼에 읽고, 버퍼의 내용을 출력한다.
                out.write(b);
            }
            
            // 버퍼에 남은 잔여 데이터를 출력해야 한다.
            out.flush();
            
            long end = System.currentTimeMillis();
            System.out.printf("걸린시간 = %d\n", end - start);
            
            // 항상 사용을 마친 자원은 해제시킨다.
            // BufferedInputStream을 close() 하면 
            // 이 클래스가 의존하는 FileInputStream도 함께 close() 된다.
            // BufferedOutputStream도 마찬가지이다.
            in.close();
            out.close();
            
            System.out.println("파일 복사 완료했음!");
        }
    }








// Data Processing Stream 바이너리 클래스 사용법 - DataInputStream 사용하기


        DataInputStream in = new DataInputStream(
                                   new FileInputStream("test3.dat"));
        
        s.setName(in.readUTF());
        s.setKor(in.readInt());



// Data Processing Stream 바이너리 클래스 사용법 - DataOutputStream 사용하기

   DataOutputStream out = new DataOutputStream(
                                    new FileOutputStream("test3.dat"));
        
   out.writeUTF(s.getName());







// FileWriter와 FileInputStream의 차이점


    // FileWriter

    public static void main(String[] args) throws Exception {
        // FileReader 
        // => 텍스트 데이터를 읽을 때 사용한다.
        // => read()를 호출하면 텍스트의 형식에 따라 
        //    1 ~ 4바이트를 읽어서 유니코드 2바이트로 변환하여 리턴한다.
        // => 변환규칙
        //    영어 : 1바이트 --> 2바이트 유니코드
        //    UTF-8: 1 ~ 4바이트 --> 2바이트 유니코드 
        
        FileReader in = new FileReader("test.txt");

        int b;
        
        while ((b = in.read()) != -1) {
            System.out.println(Integer.toHexString(b));
        }
        
        in.close();
    }



    // FileInputStream

    public static void main(String[] args) throws Exception {
        // FileInputStream 
        // => 바이너리 데이터를 읽을 때 사용한다.
        // => read()를 호출하면 1바이트를 읽어 리턴한다.
        
        FileInputStream in = new FileInputStream("test.txt");

        int b;
        
        while ((b = in.read()) != -1) {
            System.out.println(Integer.toHexString(b));
        }
        
        in.close();
    }





// FileWriter와 FileOutputStream의 차이점



    // FileWriter

    public static void main(String[] args) throws Exception {
        
        // FileWriter로 텍스트를 출력해보자!
        
        FileWriter out = new FileWriter("test3.txt");
        
        String str = "ABC가각";
        
        // String 객체의 데이터를 파일로 출력할 때
        // 자바의 2바이트 유니코드 값을 
        // JVM 실행 옵션인 "file.encoding"의 값으로 설정된
        // 문자 집합의 규칙에 따라 변환하여 출력한다.
        // 그냥 출력하는 것이 아니다.
        // 인코딩의 기준은 JVM의 file.encoding에 설정된 값을 사용한다.
        // Windows OS => 기본이 MS949
        // MacOS, Linux => 기본이 UTF-8
        // 실행할 때 인코딩을 명시하는 방법
        // => java -cp bin -Dfile.encoding=UTF-8 클래스명
        out.write(str);
        
        out.close();
        
        System.out.println("출력했습니다!");

    }


    // FileOutputStream

    public static void main(String[] args) throws Exception {
        
        // FileOutputStream으로 텍스트를 출력해보자!
        
        FileOutputStream out = new FileOutputStream("test2.txt");
        
        String str = "ABC가각";
        
        // 문자열을 출력하려면 개발자가 직접 바이트 배열을 만들어야 한다.
        byte[] bytes = str.getBytes("UTF-8");
        
        out.write(bytes);
        
        out.close();
        
        System.out.println("출력했습니다!");

    }




     Character 스트림 클래스와 Binary 스트림 클래스
     1) 캐릭터 스트림 클래스
        - Reader/Writer의 서브 클래스들.
        - 보통 클래스 이름이 Reader/Writer로 끝난다.
        - 출력할 때 자바의 유니코드 데이터를 지정한 문자집합의 바이트로 
          변환하여 출력한다.
        - 읽어들일 때 바이트의 값들을 자바의 2바이트 유니코드 값으로 
          변환하여 리턴한다.
        - 주의!
          이미지 파일과 같은 바이너리 파일을 이 클래스를 사용하여 읽으면
          문자로 간주하여 유니코드로 변환한 값을 리턴하기 때문에
          원래의 데이터가 깨지는 문제가 발생한다.
          절대로 이 클래스로 바이너리 데이터를 읽어서는 안된다.
     
     2) 바이너리 스트림 클래스
        - InputStream/OutputStream 의 서브 클래스들.
        - 보통 클래스 이름이 InputStream/OutputStream 으로 끝난다.
        - 데이터를 출력하거나 읽어들일 때 별도의 변환과정 없이
          바이트 단위 그대로 출력하고 읽는다.
        - 이 클래스를 사용하여 텍스트 데이터를 읽을 수 있지만,
          읽은 데이터를 유니코드로 변환하는 과정을 코딩해야 한다.
          불편하다.




// 데이터 프로세싱 스트림 클래스 사용법 - ObjectInputStream / ObjectOutputStream 사용하기



    public static void main(String[] args) throws Exception {
        
        // ObjectInputStream 클래스를 사용하여
        // 파일에 저장된 인스턴스 변수의 값을 읽어 보자!
        ObjectInputStream in = new ObjectInputStream(
                                    new FileInputStream("test1.dat"));
        
        Score2 s = (Score2)in.readObject(); 
        
        in.close();
        
        System.out.println(s);
    }


    public static void main(String[] args) throws Exception {
        
        Score s = new Score("홍길동", 800, 900, 1000);
        
        // ObjectOutputStream 클래스를 사용하여 인스턴스 변수의 값을 
        // 출력해보자!
        ObjectOutputStream out = new ObjectOutputStream(
                                    new FileOutputStream("test0.dat"));
        
        // ObjectOutputStream은 인스턴스 변수의 값을 
        // 바이트 배열로 만들어 출력한다.
        // => "직렬화(serialization)"이라 부른다.
        // 
        // 조건
        // => serialization을 허락해야만 직렬화를 수행할 수 있다.
        //
        // 허락하는 방법?
        // => 클래스 선언부에 java.io.Serializable 규칙을 따른다고 선언!
        //
        out.writeObject(s); // Score 클래스는 직렬화를 허락하지 않았기 
                            // 때문에 실행 오류가 발생한다!
        
        out.close();
        
        System.out.println("출력을 완료했습니다.");
    }





======================================= serialize  ======================================


// 스트림 클래스가 인스턴스 변수의 값을 serialize 할 수 있도록 허락한다.
// => java.io.Serializable 인터페이스를 구현하면 된다.
// => Serializable 인터페이스에는 아무런 메서드가 없다.
//    이 인터페이스의 목적은 단지 어떤 클래스에 대해 
//    직렬화를 허용할 것인지 여부를 지정하기 위해 
//    표시하는 용도로 사용한다.

// serialVersionUID 변수의 용도
// => java.io.Serializable 인터페이스를 구현한 클래스는 
//    자동으로 생성되는 변수이다.
// => 만약 개발자가 serialVersionUID를 지정하지 않는다면 
//    컴파일할 때 컴파일러가 임의의 값으로 설정한다.
// => serialize 데이터의 버전을 구분하기 위해 사용한다.
// => 데이터를 읽는 쪽에서는 데이터에 기록된 클래스의 버전과 
//    자신이 갖고 있는 클래스의 버전을 비교하여  
//    다르다면 예외를 발생시킴으로써 
//    데이터를 잘못 읽는 것을 방지한다.
// 
// => 클래스를 바꾼 후 serialize 한 데이터를 
//    바꾸기 전 클래스로 읽을 수 있게 하려면,
//    serialVersionUID 변수의 값을 일치시키면 된다.
// 

// 인스턴스 변수 중에는 serialize 대상이 되는 필드가 있고,
// 굳이 serialize 할 필요가 없는 필드가 있다.
// 예) 
// music 필드를 추가한 후 Score3의 값을 파일로 출력하였다.
// 데이터를 읽는 쪽에서는 Score3 클래스에 아직 music 필드가 
// 추가되지 않은 상태였다.
// 그러나 데이터를 읽어 출력해보면 합계와 평균은 
// music 데이터 값을 포함한 계산 값이었다. 
// 왜 이런 문제가 발생하였는가?
// 국,영,수,음 외에 합계와 평균도 출력했기 때문에
// 사실 합계와 평균은 과목 점수를 계산하여 나온 값이다.
// 이런 값을 출력하게 되면 
// 읽는 쪽에서 잘못된 결과를 사용할 수 있다.
// 이를 방지하기 위해서 자바에서는 
// serialize 대상에서 필드를 제외시키는 문법을 제공한다.
// => transient modifier 이다. 
// => transient의 사전적 의미를 보면 "일시적인", "잠깐 머무르는"의 
//    뜻을 갖고 있다.
// => 직렬화 대상에서 제외하고 싶은 필드가 있다면 
//    transient를 붙여라!
//    그러면 직렬화할 때 그 값은 제외된다.
//    특히 sum이나 aver 필드처럼 다른 필드의 값을 가지고 
//    도출하는 값인 경우 transient를 붙이도록 하라!
//  

public class Score4 implements Serializable {
    private static final long serialVersionUID = 1L;
    
    private String name;
    private int kor;
    private int eng;
    private int math;
    private int music;// 이 필드를 추가한다.
    
    // transient가 붙은 필드의 값을 serialize 되지 않는다.
    transient private int sum;
    private transient float aver;





======================================= Amazon Web Services ======================================



Amazon Web Services  서버   https://aws.amazon.com  무료 계정 생성



모든 서비스 > EC2


단계 1 : Amazon Machine Image 선택  : Amazon Linux AMI 2017.09 (HVM)  선택


단계 2 : General purpose   t2.micro   오른쪽 상단에서 서울 선택  > 검토 및 시작


단계 7 : 시작 클릭


    기존 키 페어 선택 또는 새키 페어 생성 : 새 키페어 생성
    
    키페어 이름 : seoul-amazon

    키페어 다운로드    seoul-amazon.pem 다운로드


    인스턴스 시작 클릭



시작 상태

  서비스 > EC2 > 실행중인 인스턴스

    퍼블릭 IP 확인


   @ seoul-amazon.pem seoul-amazon.ppk 변환

     Parameters > Type of key to generate 에서     RSA 선택

     puttygen 으로 변환  Load 클릭해서 seoul-amazon.pem 선택해서 변환




  @ putty 0.7 연결

  https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html

     MSI (‘Windows Installer’)   putty-64bit-0.70-installer.msi 다운로드


  환경설정

  - Session > Putty Host Name에  퍼블릭 IP  입력

              saved sessions : IP 그냥 입력



 - connection > ssh > auth > private key file for auther 에서 seoul-amazon.ppk 파일 경로 선택

   open 클릭 하고 예(yes) 클릭


 - putty에서  login as : ec2-user              아마존 유저 로그인




  검색 : ec2 apache install    http://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/install-LAMP.html

  
  @ Apache Web Server 설치


  [ec2-user ~]$ sudo yum update -y                  sudo (super user do)


  [ec2-user ~]$ sudo yum install -y httpd24 php70 mysql56-server php70-mysqlnd    => LAMP  Apache 웹 서버, MySQL, PHP


  [ec2-user ~]$ sudo service httpd start           Apache 웹 서버를 시작


  [ec2-user ~]$ sudo chkconfig httpd on           Apache 웹 서버가 매번 시스템이 부팅할 때마다 시작되도록 합니다
    

  [ec2-user ~]$ chkconfig --list httpd


  [ec2-user ~]$ runlevel                         linux run level 확인


  인스턴스에서 보안그룹 생성 확인  >   인바운드 22 port 

  편집 > 규칙 추가 > HTTP 선택 저장  80 port 열기    80 port 열면 브라우저로 연결됨

  브라우저에서 퍼블릭 IP 입력 


  [ec2-user ~]$ cd /var     [ec2-user ~]$ cd www    [ec2-user ~]$ ls   [ec2-user ~]$ cd html    [ec2-user ~]$ ls -al


  [ec2-user ~]$ sudo usermod -a -G apache ec2-user            ec2-user 아파치 그룹에 추가

 
  [ec2-user ~]$ exit         ec2-user 아파치 그룹추가 후 로그아웃

  
  [ec2-user ~]$ ec2-user     다시 로그인


  [ec2-user ~]$ groups               ec2-user wheel apache 그룹에 속해있음


  [ec2-user ~]$ sudo chown -R ec2-user:apache /var/www    


  [ec2-user ~]$ ls -al /var/www


  그룹 쓰기 권한을 추가하여 나중에 하위 디렉터리에 대한 그룹 ID를 설정하려면 
  /var/www와 그 하위 디렉터리의 디렉터리 권한을 변경합니다.
  [ec2-user ~]$ sudo chmod 2775 /var/www
  [ec2-user ~]$ find /var/www -type d -exec sudo chmod 2775 {} \;


  그룹 쓰기 권한을 추가하려면 /var/www 및 그 하위 디렉터리의 파일 권한을 반복하여 변경
  [ec2-user ~]$ find /var/www -type f -exec sudo chmod 0664 {} \;



  [ec2-user ~]$ echo "<?php phpinfo(); ?>" > /var/www/html/phpinfo.php


  [ec2-user ~]$ cat /var/www/html/phpinfo.php


  브라우저에서 퍼블릭IP/var/www/html/phpinfo.phs 입력

  
  var/www/html 루트 디렉토리를 삭제하고 입력  > html 하위만 볼 수 있음

  브라우저에서 퍼블릭IP/phpinfo.phs 입력


  [ec2-user ~]$ cd var/www/html


  [ec2-user ~]$ nano index.html       nano edit 실행해서 index.html 편집

      <html>
      <head>
      <title>welcome</title>
      </head>
      <body>
          <h1>welcome to My Page!</h1>
      </body>
      </html>



     ctrl + O      write out

     ctrl + x       exit

     리플레쉬



  [ec2-user ~]$ cat index.html      파일 확인




  https://www.gabia.com/  도메인 등록     가비안 선택   웹호스팅 선택 안함


  상단 mygabia  부가서비스 설정 > DNS 레코드 설정 > 신청

     www.abc.xyz    공인아이피
         abc.xyz    공인아이피   적용




======================================= 소켓 통신 ======================================



Server에서는 개발자가 port 번호 결정   1024번 ~ 49151번: 등록된 포트 (registered port)

Client은 OS 가 port 번호 결정   49152번 ~ 65535번: 동적 포트 (dynamic port)


대기열(Queue Length)은 소켓 생성 개수가 아니다.



- Network 프로그램의 운영순서

. Server : ServerSocket 생성

. Server : 포트감시 시작, Client의 접속을 기다림

. Client : Socket 생성시에 인자 값으로 서버의 IP, PORT를 지정, 서버에 접속 요구

. Server : Client의 요구를 받아 Socket 객체 생성

. Server : 생성된 Socket 객체를 이용해 Client에게 데이터를 보냄

. Client : Socket객체로 데이터를 받고 필요한 데이터를 다시 서버로 전송함



    
    static void server() throws Exception {
        ServerSocket ss = new ServerSocket(9999);
        Socket socket = ss.accept();
        
        Scanner in = new Scanner(socket.getInputStream());
        String line = in.nextLine();
        
        PrintStream out = new PrintStream(socket.getOutputStream());
        out.println(line);
        
        in.close();
        out.close();
        socket.close();
    }



    
    static void client() throws UnknownHostException, IOException {
        Socket socket = new Socket("localhost", 9999);
        
        Scanner keyScan = new Scanner(System.in);
        String message = keyScan.nextLine();
        
        PrintStream out = new PrintStream(socket.getOutputStream());
        out.println(message);
        
        Scanner in = new Scanner(socket.getInputStream());
        String line = in.nextLine();
        System.out.println(line);
    }









UML과 패턴의 적용   분석 설계


@ UML(Unified Modeling Language)

다른 사람들과의 의사소통 또는 설계 논의
전체 시스템의 구조 및 클래스의 의존성 파악
유지보수를 위한 설계의 back-end 문서

UML: 클래스 다이어그램과 소스코드 매핑 http://www.nextree.co.kr/p6753/




The Art of Computer Programming    도널드 커누스


https://github.com/samchon?tab=repositories


http://blog.eairship.kr/116


http://www.e-cartouche.ch/content_reg/cartouche/formats/en/html/Browser_learningObject1.html



@ 알고리즘 사이트
https://visualgo.net/en

@ 사이트 이동 경로 : breadcrumb

@ cache = Pooling 기법  = Lighting weight


@ 가상 머신 OS별 이미지
http://www.osboxes.org


@ Design Pattern : Best Practice, Gang of Four



http://codingdojang.com/


https://rebeccacho.gitbooks.io/java-study-group/content/index.html


https://www.gitbook.com/


Low Coupling

High Cohesion



프로가 되기 위한 웹기술 입문


Server에서는 개발자가 port 번호 결정   1024번 ~ 49151번: 등록된 포트 (registered port)

Client은 OS 가 port 번호 결정   49152번 ~ 65535번: 동적 포트 (dynamic port)






  
자바 도큐멘트 모음 
http://www.ith.kr/chair/index.html   
http://changki.net/  한글 사이트




RFC 2616 - Hypertext Transfer Protocol -- HTTP/1.1 - IETF Tools
https://tools.ietf.org/html/rfc2616#section-5


http://d2.naver.com/home



URI(Uniform Resource Identifier) -------URL(Uniform Resource Location)
                                  |
                                  |-----URM(Uniform Resource Name)



렌더링 엔진(rendering engine) 또는 레이아웃 엔진(layout engine)은 웹 콘텐츠(HTML, XML, 그림 파일 등)와 포맷 정보(CSS, XML 등)를 가져 와서 화면에 해당 콘텐츠를 정리하여 보여 주는 소프트웨어를 말한다


자바스크립트 엔진(JavaScript engine)은 자바스크립트 코드를 실행하는 프로그램 또는 인터프리터이다. 


   


statefull /stateless

https://www.joinc.co.kr/w/Site/Network_Programing/AdvancedComm/HTTP


http://recoveryman.tistory.com/179?category=595002




* gradle, maven


=================================== 라이브러리 추가 방법 ================================

1) eclipse에서 추가하는 방법

 - Eclipse의 자바프로젝트 Property에서 Biuld Path의 Libaray에서 mysql jdbc에 추가한다.



2) gradle을 이용하는 방법

 - 라이브러리 정보는 
   http://mvnrepository.com/ 에 http://mvnrepository.com/artifact/mysql/mysql-connector-java/5.1.44 에 있다.
   
   // MySQL DBMS의 JDBC Driver
   compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.44' 을

   build.gradle 파일에 dependencies {} 블록에 추가한다.


 - 추가한후 명령창에서  gradlew eclipse  실행


@ API 사용 예제

http://java-school.net/

http://www.java2s.com/Code/JavaAPI/java.sql/DriverManagergetConnectionStringurlPropertiesinfo.htm


select * from jdbc_test
as of timestamp (systimestamp - interval '10' minute)





create table jdbc_test(
  no int not null,
  title varchar(200) not null,
  conts text,
  regdt datetime not null,
  vwcnt int default 0
);

alter table jdbc_test
  add constraint primary key (no);

alter table jdbc_test
  modify column no int not null auto_increment;









IoC 용어 정리


http://isstory83.tistory.com/91

IoC 용어 정리
bean - 스프링에서 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
자바빈, EJB의 빈과 비슷한 오브젝트 단위의 애플리케이션 컴포넌트를 말한다. 하지만 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 빈은아니다. 스프링의 빈은 스프링 컨테이너가 생성과 관계설정, 사용등을 제어해주는 오브젝트를 가리킨다.

bean factory - 스프링의 IoC를 담당하는 핵심 컨테이너
빈을 등록/생성/조회/반환/관리한다. 보통은 bean factory 를 바로 사용하지 않고 이를 확장한 application context 를 이용한다. BeanFactory 는 bean factory 가 구현하는 interface 이다. (getBean()등의 메소드가 정의되어 있음)
 
application context - bean factory를 확장한 IoC 컨테이너
빈의 등록/생성/조회/반환/관리의 기능은 bean factory 와 같지만, 여기에 spring의 각종 부가 서비스를 추가로 제공한다. ApplicationContext는 application context가 구현해야 하는 interface이여, BeanFactory 를 상속한다.
 
configuration metadata (설정정보/설정 메타정보)
application context 혹은 bean factory 가 IoC를 적용하기 위해 사용하는 메타정보
스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만 주로 bean 을 생성/구성하는 용도로 사용된다.
 
container (IoC container)
IoC 방식으로 bean을 관리한다는 의미에서 bean factory 나 application context 를 가리킨다. 
(spring container = application context) application context는 그 자체로 ApplicationContext 인터페이스를 구현한 오브젝트를 가리키기도 하는데, 하나의 애플리케이션에 보통 여러개의 ApplicationContext Object가 만들어진다. 이를 통칭해서 strping container라고 부를 수 있다.
간단하게, 객체를 관리하는 컨테이너이다, 컨테이너에 객체를 담아 두고, 필요할 때에 컨테이너로부터 객체를 가져와 사용할 수 있도록 하고 있다.
 
spring framework - IoC container, application context 를 포함해서 spring이 제공하는 모든 기능을 통칭한다.






java log4j 설정



Java Example

https://www.programcreek.com/java-api-examples/index.php

http://tcpschool.com/java/java_intro_java8

http://androphil.tistory.com/


라이브러리 검색 사이트
http://mvnrepository.com/

reflection 아니고 reflections 검색해서 gradle

// https://mvnrepository.com/artifact/org.reflections/reflections
compile group: 'org.reflections', name: 'reflections', version: '0.9.11'

주소를 가지고 와서 build.gradle 의 properties에 추가

gradlew eclipse


https://github.com/ronmamo/reflections

https://mdn.mozilla.org/ko/

스프링 강좌
http://wiki.gurubee.net/display/LECTURE/Home
https://yangbongsoo.gitbooks.io/study/





 * IoC 컨테이너   http://ooz.co.kr/170
   어떠한 객체의 명세서를 작성하고, 스프링 라이브러리는 해당 명세대로 객체를 생성. 
   생성된 객체(그리고 디펜던시)들을 보관하는 공간을 의미.




* EJB : Enterprise Java Bean (엔터프라이즈 자바빈) 
 ? 효율적으로 서버 관리를 해주고, 또 프로그램 관련 문제들을 알아서 처리해준다는 개념.
   (연결 관계가 복잡하고, 무겁고, 독립적이지 못하다)


* DL : Dependency Lookup 

* DI : Dependency Injection


* DI (Dependecy Injection) 
  ? 각 class 사이의 의존관계를 빈 설정 정보를 바탕으로 
    container가 자동적으로 연결해 주는 것을 말함. 
    따라서 lookup과 관련된 코드들이 오브젝트 내에서 완전히 사라지고 
    컨테이너에 의존적이지 않은 코드를 작성할 수 있음.
    단지 빈 설정 파일에서 의존관계가 필요하다는 정보를 추가하면 됨.




* xml namespace
    xmlns:p="http://www.springframework.org/schema/p"






1) Constructor Injection 
   ? 클래스 사이의 의존관계를 연결시키기 위하여 constructor를 이용하는 방법. 
     constructor-arg tag 사용. 
     <constructor-arg type="String" index="0" value="홍길동"/>


    <bean class="bitcamp.java100.ch20.ex2.MyClass3" 
          c:left="1.5" c:right="1.2"/>


    <bean class="bitcamp.java100.ch20.ex2.MyClass3">
        <constructor-arg ref="obj1"/>
    </bean>

2) Setter Injection 
   - 클래스 사이의 의존관계를 연결시키기 위하여 setter 메소드를 이용하는 방법. 
     property tag 사용. 
     <property name="name" value="비트엔진"/>

    <bean id="e1" class="bitcamp.java100.ch20.ex3.Engine"
          p:name="비트엔진" p:cc="5000" p:valve="16"/>


    <bean id="c2" class="bitcamp.java100.ch20.ex3.Car">
        <property name="engine" ref="e1"/>
    </bean>

    <bean id="c3" class="bitcamp.java100.ch20.ex3.Car"
          p:engine-ref="e1"/>


3) Method Injection 
   ? 싱글톤(Singleton) 인스턴스와 non singleton 인스턴스의 
     의존관계를 연결시킬 필요가 있을 때 사용하는 방법.




    <!-- Map 컬렉션 객체 주입하기 
        Car c1 = new Car();
        
        Map<String,String> map = new HashMap<>();
        map.put("sunroof", "yes");
        map.put("airbag", "yes");
        map.put("blackbox", "no");
        
        c1.setOptions(map);    
    -->

    <bean id="c1" class="bitcamp.java100.ch20.ex4.Car">
        <property name="options">
          <map>
            <entry>
                <key><value>sunroof</value></key>
                <value>yes</value>
            </entry>
            <entry key="airbig">
                <value>yes</value>
            </entry>
            <entry key="blackbox" value="no"/>
          </map>
        </property>
    </bean>




https://tomcat.apache.org/  에서 




apache-tomcat > logs > 폴더에서 서버 접속 log가 남겨져 있다.


Tomcat log 파일 보는 법   tail

tapache-tomcat > logs > 로 이동하여

tail -f catalina.out
또는 날자에 해당하는 .log를 tail -f ***.log 와 같은방법으로 열면된다

빠져나오기는 ctrl + c






//==================================================================
//* 톰캣 설치 및 서버 실행
//==================================================================

 기존 방식의 문제점
 - HTTP 프로토콜을 정교하게 제어하지 못한다.
 - 그래서 웹브라우저의 일반적인 요청을 처리하지 못했다.
   예를 들면, favicon.ico이나 기타 정적인 HTML 문서를 요청할 때 
   적절하게 처리하지 못했다.
 - 가장 중요한 문제는 컨트롤로를 만들 때 자체 인터페이스를 정의하여 
   만들었기 때문에 다른 프로젝트나 다른 제품과 호환되지 않는다.

 해결 방안
 - 이미 검증되고 널리 사용되는 표준 규격에 따라 프로그램 만들어 
   다양한 프로젝트나 시스템에서도 적용될 수 있게 호환성을 확보한다.
 - 그래서 JavaEE의 Servlet 기술을 도입하여 처리한다.
 - 변경코드  
   0) JavaEE의 서블릿 기술을 다룰 수 있도록 라이브러리를 가져온다. 
      => mvnrepository.com에서 servlet-api를 찾는다.
      => build.gradle에 의존 라이브러리 정보를 등록한다.
         - 'war' gradle 플러그인 을 추가한다.
         - 의존 라이브러리 정보를 추가한다. 
      => "gradlew eclipse"를 실행하여 이클립스 설정 파일을 갱신한다. 
      => 이클립스 프로젝트를 "Refresh" 한다.

   1) App 클래스 변경
      => App 클래스도 "톰캣" 서블릿 컨테이너에서 실행하도록 만든다.
         즉 Servlet 규칙에 따라 만든다.
      => 컨트롤러를 호출하는 것은 "톰캣" 서블릿 컨테이너에게 맡긴다.
      => 대신 스프링 IoC 컨테이너를 이용하여 DAO와 DB 커텍션풀을 준비한다.

   2) 컨트롤러를 JavaEE의 Servlet 규격에 맞춰 변경한다.
      => 각 컨트롤러의 이름에서 접미사 Controller 대신에 Servlet으로 바꾼다.
      => 우리가 만든 Controller 인터페이스 대신에 
         JavaEE에서 제공하는 Servlet 인터페이스를 구현한다.
      => 컨트롤러에 @WebServlet을 붙여 서블릿 컨테이너가 알아 볼 수 있게 한다.

   3) 서블릿 컨테이너 제품 중에 하나인 "톰캣"을 다운로드 받는다.
      => tomcat.apache.org 사이트에 간다.
      => servlet 3.1 규격에 따라 만든 8.5.x 버전을 다운로드 받는다.
      => window(c:\Users\사용자폴더\ 에 압축을 푼다), linux/macOS(홈폴더에 푼다)

   4) 톰캣 웹 애플리케이션 폴더에 이 프로그램을 배치한다.
      => $tomcat_home/webapps/bitcamp 폴더를 생성한다.
      => bitcamp/classes 폴더를 생성한다.
         이 폴더에 우리가 만든 클래스 파일(.class)을 둔다.
      => bitcamp/lib 폴더를 생성한다.
         이 폴더에 우리가 사용한 라이브러리 파일(.jar)을 둔다.
      => 이 모든 것을 한 방에 배치할 수 있는 방법이 있으니,
         gradle 빌드 도구를 사용하는 것이다.
         - "gradlew build"를 실행한다.
         - 프로젝트폴더/build/libs/프로젝트명.war 파일이 생성되었을 것이다.
         - 이 war(Web ARchive 파일)에 우리가 만든 클래스들과 라이브러리 파일들이
           묶여서 들어 있다.
         - 이 파일을 $tomcat_home/webapps/ 폴더에 복사해 놓으면 된다.
         - 웹 애플리케이션 이름은 .war 파일명이 될 것이다.

   5) 톰캣 서버의 포트 번호를 8080에서 9999로 변경한다.
      => 이유? 
         운영체제에 이미 8080을 사용하는 프로그램이 있을 수 있다.
         특히 오라클 DBMS를 설치하면 오라클 기본 웹서버가 8080을 사용한다.
      => 이런 경우를 방지하고자 그냥 무조건 포트번호를 9999로 바꾼다.
      => 톰캣홈/conf/server.xml 파일에서 8080 포트 부분을 찾아 9999로 바꾼다.

   6) 톰캣 서버를 실행한다.
      => "echo %JAVA_HOME%"을 실행하여 JDK 폴더가 제대로 설정되었는지 확인한다.
         linux/macOS 는 "echo $JAVA_HOME"을 실행한다.
      => "java -version" 을 실행하여 JDK 버전과 일치하는 지 확인한다.
      => "javac -version" 을 실행하여 JDK 버전과 일치하는 지 확인한다.
      => 파일 탐색기에서 "톰캣홈/bin/startup.bat"를 실행한다.
         linux/macOS
         > cd 톰캣홈/bin
         > chmod 755 *.sh  를 실행하여 쉘스크립트 파일을 실행가능한 상태로 만든다.
         > ./startup.sh를 실행한다.


   7) localhost:9999 입력후 톰캣 서버 Manger App클릭해서 Tomcat Web Application Manager에서
      톰캣이 정상적으로 실행되는지 확인
      => 로그인은 톰캣홈/conf/tomcat-users.xml 파일에 아래를 추가해서 수정

           <role rolename="manager-gui"/>
           <user username="tomcat" password="1111" roles="manager-gui"/>




 작업
 1) App 클래스의 이름을 AppInitServlet 클래스로 변경한다.
 2) Servlet 규격에 맞추어 클래스를 만든다.
    - javax.servlet.Servlet 인터페이스를 구현한다.
    - Servlet 인터페이스에 선언된 모든 메서드를 구현한다.
 3) 이 클래스를 서블릿 컨테이너가 알아볼 수 있도록 
    @WebServlet 애노테이션을 붙인다.
    - name 속성을 이용하여 서블릿의 별명을 지정하라!
    - 사용자가 요청하지 않아도 자동으로 생성되게 loadOnStartup 속성을 추가하라!


  
  <!-- Login Test -->
  <filter>
    <filter-name>RequestLoggingFilter</filter-name>
    <filter-class>login.RequestLoggingFilter</filter-class>
  </filter>
  
  <filter-mapping>
    <filter-name>RequestLoggingFilter</filter-name>
    <url-pattern>/*</url-pattern>
    <dispatcher>REQUEST</dispatcher>
  </filter-mapping>
  
  <filter>
    <filter-name>AuthenticationFilter</filter-name>
    <filter-class>login.AuthenticationFilter</filter-class>
  </filter>
  
  <filter-mapping>
    <filter-name>AuthenticationFilter</filter-name>
    <url-pattern>/*</url-pattern>
  </filter-mapping>
  <!-- Login Test -->





//==================================================================
// GET vs POST
//==================================================================

 [GET 요청]
 - 특징
   => 데이터를 보낼 때 URL에 붙여 보낸다.
   => 서버에 보내는 데이터가 웹 브라우저의 URL 주소창에 보인다.
      => URL은 웹 브라우저에서 방문 내역에 보관한다.
      => 누구든 그 전에 방문한 페이지와 데이터를 볼 수 있다.
      => 로그인과 같은 보안을 요구하는 경우 GET이 맞지 않다.
  => 페이지 주소와 보내는 데이터를 묶어 보관하거나 전달하기 쉽다.
      => 다른 사람에게 특정 페이지의 링크를 쉽게 보낼 수 있다.
      => 즐겨 찾기나 북마크로 해당 페이지의 주소를 저장할 수 있다.
   => 데이터를 보낼 때 URL에 붙여 보내기 때문에 바이너리 데이터를 보낼 수 없다.
      => 만약 바이너리 데이터를 보내려면 Base64와 같은 인코딩 방식을 사용하여
         바이너리를 텍스트로 변환시켜 보내야 한다.
   => 웹서버 중에는 HTTP Request-line의 크기를 8KB로 제한하는 서버가 있다.
      그런 경우 바이너리 데이터를 보내더라도 크기에 제약이 생기기 때문에
      바이너리 데이터를 보내기에 적합하지 않다.
   => 그러나 최근에 RESTful 방식으로 동작시키는 웹 애플리케이션이 많다 보니,
      request-line이나 요청 헤더의 최대 크기를 더 높인 경우가 많다.
      그리고 웹서버 관리자가 제한하는 크기에 따라 더 커질 수 있다. 
      * RESTFul 방식에서는 서버에 데이터를 보낼 때 요청 헤더에 붙여서 
        보낸다.
 - 특징 요약
   => URL에 데이터를 붙인다.
   => 웹브라우저창에 데이터가 노출되어 보안에 안좋다.
   => 서버에 바이너리 데이터를 보낼 수 없다.
   => 보내는 데이터의 크기에 제약이 있다.
 - 용도
   => 게시물 조회 페이지 링크
   => 검색어처럼 URL에 포함시켜야 할 때 
   => 즐겨 찾기나 북마크에 포함시키고 싶을 때 
 
 [POST 요청]
 - 특징
   => 데이터를 보낼 때 message-body 영역에 보낸다.
   => 서버에 보내는 데이터가 웹 브라우저의 URL 주소창에 보이지 않는다.
      => 웹 브라우저가 방문 내역을 저장할 때, 
         서버에 보내는 데이터는 저장하지 않는다.
      => 다른 사용자가 이전 사용자가 방문한 페이지는 볼 수 있어도 
         보낸 데이터를 알 수 없다.
   => 페이지 주소와 보내는 데이터를 묶어 보관할 수 없다.
      => 즐겨 찾기나 북마크에 해당 페이지를 저장할 수 없다.
   => 데이터를 보낼 때 message-body 영역에 보내기 때문에 
      "multipart 인코딩" 방식을 사용하면 텍스트로 변환할 필요없이 
      바이너리 데이터를 보낼 수 있다.
   => 보통 웹서버는 POST 방식으로 보내는 데이터에 대해 크기 제한을 두지 않는다.
      다만 개발자가 애플리케이션을 개발할 때 받아들이는 데이터의 크기를
      제한 할 뿐이다.
      설사 웹서버가 관리자가 크기의 제한을 두더라도 GET 방식과 달리 
      더 큰 용량의 데이터를 전송할 수 있도록 해준다.
 - 특징 요약
   => 요청 프로토콜에서 message-body 부분에 데이터를 보낸다.
   => 웹브라우저 주소창에 데이터를 노출시키지 않는다. 
   => 바이너리 데이터를 전송할 수 있다.
   => 보내는 데이터의 크기에 제약이 거의 없다.
 - 용도
   => URL에 데이터를 포함하지 않는다.
   => 로그인처럼 외부에 데이터가 노출되지 않아야 하는 경우.
   => 데이터 조회 보다는 데이터를 많이 보내는 입력이나 변경하는 경우.
   => 바이너리 데이터를 보내는 경우.








//==================================================================
// GET/POST과 HEAD 요청의 차이점
//==================================================================



 [GET/POST 요청]
 => 웹서버에 콘텐츠를 요청한다.
 => 웹서버는 클라이언트에서 요청한 콘텐츠를 보낸다.

 [HEAD 요청]
 => 콘텐츠 부가 정보만 요청한다.
 => 웹서버는 콘텐츠의 부가 정보만 보낸다.
    콘텐츠는 보내지 않는다.
 => 용도 
    콘텐츠의 변경 여부를 검사하기 위해 요청한다.
    예) 
    1. 사용자가 URL을 입력한 후 엔터를 친다.
    2. 웹브라우저는 먼저 내부 캐시 폴더에서 이전에 받은 데이터가 있는지 
       검사한다.
    3. 없다면, 서버에 GET 요청을 보낸다.
       3-1. 서버는 콘텐츠의 부가 정보와 콘텐츠 데이터를 보낸다.
    4. 있다면, 서버에 HEAD 요청을 보낸다.
       4-1. 서버는 콘텐츠의 부가 정보만 보낸다.
       4-2. 웹브라우저는 내부에 임시 보관된 콘텐츠의 날짜 정보와 비교해서
            같은 날짜면, 내부에 보관된 콘텐츠를 출력한다.
            다른 날짜면, 서버에 GET 요청을 보내 다시 콘텐츠를 다운로드 받는다.
            그리고 출력한다.
    매번 같은 콘텐츠를 서버에서 다운로드 받는다면 출력 속도가 느릴 것이다.
    그래서 현대의 대부분의 웹브라우저는 자체 캐싱(caching;임시 보관)기능을 갖고 있다.
    사용자가 요청하면 내부에 보관된 데이터를 바로 출력함으로써 
    출력 속도를 높이는 방식이다.
    문제는 서버에서 콘텐츠를 바꾸게 되면 이전에 저장된 데이터는 
    낡은 데이터이기 때문에 화면에 출력하며 안된다.
    이런 상황을 해결하기 위해 나온 것이 HEAD라는 요청이다.

